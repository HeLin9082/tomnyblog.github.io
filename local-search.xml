<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ESM模块化开发案例</title>
    <link href="/tomnyblog.github.io/2024/05/09/Z-ESModulePro/"/>
    <url>/tomnyblog.github.io/2024/05/09/Z-ESModulePro/</url>
    
    <content type="html"><![CDATA[<p>接着上一篇前端模块化的学习，继续ES模块化案例详解，本篇为 webpack + babel 构建编译和打包ES6模块的过程…</p><span id="more"></span><p>本文注重 webpack + babel 构建编译和打包es6模块的过程，偏向模块化环境构建演示，不具体es6的语法代码深入。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="1、创建项目与初始化"><a href="#1、创建项目与初始化" class="headerlink" title="1、创建项目与初始化"></a>1、创建项目与初始化</h3><p>前提：安装好node.js，打开命令行工具，查看node和npm正确显示版本号。<br>创建一个项目文件夹：myESM-project ，进入项目使用npm初始化项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init -y<br></code></pre></td></tr></table></figure><h3 id="2、项目结构"><a href="#2、项目结构" class="headerlink" title="2、项目结构"></a>2、项目结构</h3><p>创建项目文件夹后，创建项目结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">myESM-project<br>|-js  <br>    |-dist //打包生成文件的目录 （可打包命令时生成，无需手动创建）  <br>    |-src //源码所在的目录    <br>        |-app.js    // 应用主源文件（编译打包模块的主入口）<br>        |-module1.js    <br>        |-module2.js    <br>        |-module3.js <br>|-index.html    // 运行于浏览器上 <br>|-package.json  // (npm初始化自动创建)<br>|-.babelrc      // babel配置文件。（手动创建）文件名包括&quot;.&quot; 或者 babel.config.json 取决你的偏好<br>|-webpack.config.js  // webpack配置文件（手动创建）<br><br></code></pre></td></tr></table></figure><h3 id="3、安装-webpack-和-babel-的相关依赖包"><a href="#3、安装-webpack-和-babel-的相关依赖包" class="headerlink" title="3、安装 webpack 和 babel 的相关依赖包"></a>3、安装 webpack 和 babel 的相关依赖包</h3><p>基础安装 5个 依赖包配置打包js的模块（css和image等其它loaders配置待续）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env --save-dev（或-D）<br><br>// webpack 和 webpack-cli 是 Webpack 的核心和命令行工具。<br>// babel-loader 是 Webpack 的一个 loader，用于将 Babel 整合到 Webpack 的构建流程中。<br>// @babel/core 是 Babel 的核心库。<br>// @babel/preset-env 是一个智能预设，可以根据你的目标环境自动启用所需的 Babel 插件。<br><br></code></pre></td></tr></table></figure><h3 id="4、项目文件相关配置"><a href="#4、项目文件相关配置" class="headerlink" title="4、项目文件相关配置"></a>4、项目文件相关配置</h3><p>安装相关依赖包后对babel预设以及webpack配置：(根目录下手动创建 2个 配置文件)<br>配置babel：<br>.babelrc 文件（或者 babel.config.json 取决你的偏好），并添加以下配置(json格式)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;  <br>    &quot;presets&quot;: [&quot;@babel/preset-env&quot;]  <br>&#125;<br><br>（告诉 Babel 使用 @babel/preset-env 预设来转码你的代码）<br><br></code></pre></td></tr></table></figure><p>配置webpack：<br>webpack.config.js 文件，并添加以下基础配置（js格式）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js 文件 (在这个文件可以定义入口点、输出配置、加载器(loaders)等)</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);  <br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./js/src/app.js&#x27;</span>,    <span class="hljs-comment">// 入口文件  </span><br>    <span class="hljs-attr">output</span>: &#123;  <br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,      <span class="hljs-comment">// 打包后的文件名  </span><br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./js/dist&#x27;</span>),  <span class="hljs-comment">// 打包后文件的输出路径  </span><br>    &#125;,  <br>    <span class="hljs-attr">module</span>: &#123;  <br>        <span class="hljs-attr">rules</span>: [&#123;  <br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,           <span class="hljs-comment">// 匹配 .js 文件  </span><br>            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,        <span class="hljs-comment">// 排除 node_modules 目录  </span><br>            <span class="hljs-attr">use</span>: &#123;  <br>                <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,     <span class="hljs-comment">// 使用 babel-loader 来转译 ES6 代码  </span><br>                <span class="hljs-attr">options</span>: &#123;  <br>                    <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]      <span class="hljs-comment">// 使用 @babel/preset-env 预设(传递选项给 loader)   </span><br>                &#125;  <br>            &#125;  <br>        &#125;]  <br>    &#125;  <br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="5、编写模块代码与构建打包项目"><a href="#5、编写模块代码与构建打包项目" class="headerlink" title="5、编写模块代码与构建打包项目"></a>5、编写模块代码与构建打包项目</h3><p>编写代码：<br>&nbsp;&nbsp;&nbsp;&nbsp;现在项目中可以开始编写 ES6 代码了。例如在app.js文件导入module1、module2、module3和module4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//module1.js 文件  (单独导出 —— 命名函数）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---这里是module1.js的foo()---&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---这里是module1.js的bar()---&#x27;</span>)<br>&#125;<br><br><br><br><span class="hljs-comment">//module2.js 文件  (统一导出 —— 命名函数）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---这里是module2.js的fun1()---&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---这里是module2.js的fun2()---&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; fun1, fun2 &#125;<br><br><br><br><span class="hljs-comment">//module3.js 文件  (默认导出 —— 匿名函数及调用命名函数）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun3</span>(<span class="hljs-params">params</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---这里是-module3.js--默认导出匿名函数使用的外函数fun3---&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---这里是module3.js---默认导出的匿名函数&#x27;</span>);<br>    funModule3<br>&#125;<br><br><br><br><span class="hljs-comment">//module4.js 文件  (默认导出 —— 对象）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <br>    <span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;---这里是-module4.js---默认导出的对象--属性str。&#x27;</span>,  <br>    <span class="hljs-title function_">fun4</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---这里是module4.js---默认导出的对象--方法fun4---&#x27;</span>); <br>     &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//app.js 文件  (模块主入口——导入模块并调用模块)</span><br><span class="hljs-keyword">import</span> &#123; foo, bar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module1&#x27;</span><br><span class="hljs-keyword">import</span> &#123; fun1, fun2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module2&#x27;</span><br><span class="hljs-keyword">import</span> module3 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module3&#x27;</span><br><span class="hljs-keyword">import</span> module4 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module4&#x27;</span><br><br><span class="hljs-comment">// 需要使用第三方模块时（npm安装好jquery在项目内）</span><br><span class="hljs-comment">// import $ from &#x27;jquery&#x27;</span><br><span class="hljs-comment">// $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;);</span><br><br><span class="hljs-comment">// 所有的模块导入后调用</span><br><span class="hljs-title function_">foo</span>()<br><span class="hljs-title function_">bar</span>()<br><span class="hljs-title function_">fun1</span>()<br><span class="hljs-title function_">fun2</span>()<br><span class="hljs-title function_">module3</span>()<br>module4.<span class="hljs-title function_">fun4</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(module4.<span class="hljs-property">str</span>);  <span class="hljs-comment">//（调用默认导出的对象属性）</span><br>  <br><span class="hljs-comment">// 获取html主入口元素</span><br><span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ele&#x27;</span>);  <span class="hljs-comment">// 获取元素</span><br>element.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;数据：&#x27;</span> + module4.<span class="hljs-property">str</span>;  <span class="hljs-comment">// 打包后渲染</span><br><br></code></pre></td></tr></table></figure><p>构建项目：<br>使用命令：运行 Webpack 命令来构建你的项目。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">终端：npm webpack --mode development<br>或者：npx webpack --mode development<br></code></pre></td></tr></table></figure><p>或使用简化命令：构建命令在 package.json 文件中添加一个脚本命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot;scripts&quot;: &#123;  <br>    &quot;build&quot;: &quot;webpack --mode development&quot;  <br>&#125;<br>使用命令：npm run build<br>命令参数详解：<br>--mode development 告诉 Webpack 使用开发模式配置，通常是更详细的错误信息和更小的压缩包，便于调试。<br>--mode production 告诉 Webpack 使用生产模式配置。<br><br></code></pre></td></tr></table></figure><p>构建后检查 Webpack 会在你指定的输出目录中（此例子中是 dist&#x2F; 目录）生成一个 bundle.js 文件，<br>这个文件包含了所有必要的转译后的代码，以及通过 Webpack 打包的依赖项。</p><h3 id="6、在浏览器运行文件"><a href="#6、在浏览器运行文件" class="headerlink" title="6、在浏览器运行文件"></a>6、在浏览器运行文件</h3><p>在 HTML 中引用打包后的文件：<br>引入打包好的 bundle.js 文件，浏览器就可以执行 ES6 的代码了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">（引入放置页面底部body标签前）<br>&lt;script src=&quot;./js/dist/bundle.js&quot;&gt;&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p><br><br><br><br>（待续…）<br><br><br></p><p style="font-size: 10px">注：<br>本站商业转载需<a href="https://email.163.com/">联系博主:wyyx9082hgl@163.com</a>授权，非商业转载请注明出处。<br>    无法联系博主请在评论区注明，未经授权或无联系方式相关法律责任问题将追究。</p><p style="font-size: 10px">    本站为学习交流使用，非商业用途。如有资源侵权请<a href="https://email.163.com/">[联系博主]</a>，感谢您的支持！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前后端</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端模块化开发</title>
    <link href="/tomnyblog.github.io/2024/05/05/Zmodularization/"/>
    <url>/tomnyblog.github.io/2024/05/05/Zmodularization/</url>
    
    <content type="html"><![CDATA[<p>什么是模块化？怎么样模块化？为什么要模块化？了解下</p><span id="more"></span><p>如果没有特别深入的学习（如博主小白）…可以先从案例出发（怎么样模块化？）再回头来了解模块化。<br></p><!-- 前言：<br>  首先，在找模块化学习的你起码有些前端技术水平，但还是要先具备一些技术或思想:  <br>第一个是 HTML-CSS-JavaScript 基础掌握（当然模块化也属于JS的学习之一），ECMAScript 5是满足不了模块化技术扩展的，就像本文的 ES Module 需掌握ECMAScript 2015（ES6）基础。当然，ES6包括了ES的模块学习，本文涉及的是进展；<br>二是要理解并掌握模块化就不仅仅需要熟知模块的关联方式、接口书写、组装还有解构（拆解），最好还要熟悉函数式编程、类--><h2 id="什么是模块化？"><a href="#什么是模块化？" class="headerlink" title="什么是模块化？"></a>什么是模块化？</h2><p>  模块化的定义基本是：将一个大型的前端应用程序（或复杂的系统）分解拆为小的、‌独立的模块，每个模块有自己的用途功能或职责，并可以通过规范化标准化的接口与其它模块进行交互、组装。<br><br>  反过来理解就是：做好的每个模块有自己的功能或职责，两个或多个模块通过规范好的接口，可以组装拼接成一个系统或应用程序；<br><br>  前端模块化的大概定位： <br><br>    大者：模块化 ——&gt; 模块模式 ——&gt; 设计模式(系统化方法) ——&gt; 软件设计模式 ——&gt; (笼统定位)… 软件工程 ——&gt; …(笼统定位) ——&gt; 系统或应用 <br><br>    小者：模块化 ——&gt; 模块 ——&gt; (程度上)组件化 ——&gt; 函数、类、变量… ——&gt; 对象 ——&gt; (笼统定位)… ——&gt; 0或1<br>  <br><br>  通俗点模块就比如一辆车，整辆车生产是一个项目，车门、车轮、座椅、…等等就是一个个模块有自己的功能和复用性，组入车架(项目底层架构环境)组装起来就是完整的车…</p><p>  所以，设计模式的模块化也是一种思想，也是一种艺术…<br>  <br><br></p><h3 id="模块化的发展：（笼统定义-—-Module模式前的演变）"><a href="#模块化的发展：（笼统定义-—-Module模式前的演变）" class="headerlink" title="模块化的发展：（笼统定义 — Module模式前的演变）"></a>模块化的发展：（笼统定义 — Module模式前的演变）</h3><h4 id="1、全局-function-模式-将不同的功能封装成不同的全局函数；"><a href="#1、全局-function-模式-将不同的功能封装成不同的全局函数；" class="headerlink" title="1、全局 function 模式 : 将不同的功能封装成不同的全局函数；"></a>1、全局 function 模式 : 将不同的功能封装成不同的全局函数；</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 声明一个函数，也是全局变量 m1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123; &#125;    <br><span class="hljs-comment">// 声明一个函数，也是全局变量 m2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123; &#125; <br></code></pre></td></tr></table></figure><p> <span style="color:red">引发问题: </span>污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系；</p><h4 id="2、namespace-模式-简单对象封装；减少了全局变量，解决命名冲突"><a href="#2、namespace-模式-简单对象封装；减少了全局变量，解决命名冲突" class="headerlink" title="2、namespace 模式 : 简单对象封装；减少了全局变量，解决命名冲突"></a>2、namespace 模式 : 简单对象封装；减少了全局变量，解决命名冲突</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myModule = &#123;  <br>  <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;www.度娘.com&#x27;</span>,  <br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`foo() <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.data&#125;</span>`</span>)  <br>  &#125;,  <br>  <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;   <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`bar() <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.data&#125;</span>`</span>)  <br>  &#125;<br>&#125;<br>myModule.<span class="hljs-property">data</span> = <span class="hljs-string">&#x27;other data&#x27;</span>;   <span class="hljs-comment">// 外部可直接修改模块内部数据</span><br>myModule.<span class="hljs-title function_">foo</span>();    <span class="hljs-comment">// foo() other data （内部数据被改写）</span><br></code></pre></td></tr></table></figure><p> <span style="color:red">引发问题: </span>状态与数据不安全。这写法会暴露所有模块成员，内部状态与数据可直接被外部改写。</p><h4 id="3、IIFE-模式：（匿名函数自调用-闭包）"><a href="#3、IIFE-模式：（匿名函数自调用-闭包）" class="headerlink" title="3、IIFE 模式：（匿名函数自调用-闭包）"></a>3、IIFE 模式：（匿名函数自调用-闭包）</h4><p>  全称：IIFE（Immediately Invoked Function Expression），即立即调用函数表达式。<br>  作用: 为隔离作用域，防止污染全局命名空间；数据私有，外部只能操作已暴露的方法。<br>  方式: 封装数据和行为到一个函数内部，给全局对象 window 添加属性来向外暴露接口。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs text">// 函数作用域+闭包<br>function fun() &#123;<br>  let name = &quot;module&quot;;<br>  return &#123;<br>    get() &#123;<br>      return name;<br>    &#125;,<br>    set(newName) &#123;<br>      name = newName;<br>    &#125;,<br>  &#125;;<br>&#125;<br>​<br>console.log(name);  // undefind<br>const Name = fun();<br>console.log(Name.get());  // module<br><br>// 若要改变函数内属性的值，只有通过暴露出来的方法进行修改，否则无法修改，这符合模块化的标准<br>Name.set(&quot;new_module&quot;);<br>console.log(Name.get());  // new_module<br><br><br><br>// 使用闭包进行模块化的改造，创建一个自执行的闭包函数。<br><br>(() =&gt; &#123;<br>  let name = &quot;module&quot;;<br>  function getCoordinate() &#123; return [Math.random() * 100, Math.random() * 100]; &#125;<br><br>  function handleData(data) &#123; return [Math.floor(data[0]), Math.floor(data[1])]; &#125;<br>  <br>  function sum(a, b) &#123; return a + b; &#125;<br>  <br>  function getName() &#123; return name; &#125;<br>  function setName(newName) &#123; name = newName; &#125;<br>  window.__Module = &#123;<br>      name,<br>      getCoordinate,<br>      handleData,<br>      sum,<br>      getName,<br>      setName,<br>  &#125;;<br>&#125;)();<br>​<br>const module = window.__Module;<br>const coordinate = module.getCoordinate();<br>const data = module.handleData(coordinate);<br>const result = module.sum(data[0], data[1]);<br>console.log(result);    // 125<br>console.log(module.name);    // module<br>module.name = &quot;new_module&quot;;<br>console.log(module.name);     // new_module<br><br>// 对 module.name 的值进行修改，然后打印发现结果为修改后的值，这与之前提到的私有行为相矛盾；<br>// 问题本质上是函数作用域与对象属性的区别，在闭包方法中name属性添加到返回结果中，这其实是对name的一个拷贝，而不是函数内部的name<br>//只有通过getName才能拿到内部属性name的值，也只有通过 setName 才能改变内部属性 name 的值<br><br>console.log(module.getName());    // module<br>module.setName(&quot;new_module&quot;)<br>console.log(module.getName());    // new_module<br></code></pre></td></tr></table></figure><p>  <span style="color:red">引发问题: </span>不能处理当前这个模块依赖另一个模块的场景，且模块间通讯存在问题。<br>  <span style="color:red">结论：</span>无法解决模块之间相互依赖的问题。</p><h4 id="4、IIFE-模式增强-引入依赖-（———现代模块的基本，大都jQ的项目实现———）"><a href="#4、IIFE-模式增强-引入依赖-（———现代模块的基本，大都jQ的项目实现———）" class="headerlink" title="4、IIFE 模式增强: 引入依赖      （———现代模块的基本，大都jQ的项目实现———）"></a>4、IIFE 模式增强: 引入依赖      （———现代模块的基本，大都jQ的项目实现———）</h4><p>  模式的增强：在原来的 IIFE 模式基础上引入第三方模块。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs text">// 使用 ES6 案例<br>((global) =&gt; &#123;<br>  function handleData(data) &#123;<br>    return [Math.floor(data[0]), Math.floor(data[1])];<br>  &#125;<br>  function sum(a, b) &#123;<br>    return a + b;<br>  &#125;<br>  global.__Module_utils = &#123;<br>    handleData,<br>    sum,<br>  &#125;;<br>&#125;)(window);<br>​<br>// 上面没有引入依赖，对比 以下引入依赖<br><br>((global, module) =&gt; &#123;<br>  function getCoordinate() &#123;<br>    return [Math.random() * 100, Math.random() * 100];<br>  &#125;<br>  global.__Module = &#123;<br>    getCoordinate,<br>    handleData: module.handleData,<br>    sum: module.sum,<br>  &#125;;<br>&#125;)(window, window.__Module_utils);<br>​<br>const module = window.__Module;<br>const coordinate = module.getCoordinate();<br>const data = module.handleData(coordinate);<br>const result = module.sum(data[0], data[1]);<br>console.log(result);<br></code></pre></td></tr></table></figure><p>再看一个引入依赖的增强模式简单案例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs text">// app.js<br>(function(window, $) &#123;  <br>  // 私有数据<br>  let data = &#x27;www.度娘.com&#x27;;  <br>  //用于暴露<br>  function x() &#123;        <br>    console.log(`x() $&#123;data&#125;`);<br>    $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;yellow&#x27;);<br>  &#125;  <br>  // 暴露模块接口<br>  window.myModule = &#123; x &#125;<br>&#125;)(window, jQuery)<br><br>// index.html文件<br>  &lt;!-- 引入顺序有要求：当先引入模块再引入jquery时，报错 --&gt;<br>  &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;<br>  &lt;script type=&quot;text/javascript&quot; src=&quot;app.js&quot;&gt;&lt;/script&gt;<br>  &lt;script type=&quot;text/javascript&quot;&gt;<br>    myModule.x();<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><p><span style="color:red">引发问题：</span>当需要很多请求时，需要很多模块，加载会阻塞；模块引入顺序有要求也导致了难以维护<br><span style="color:red">结论：</span>传入多个参数依赖，代码阅读变得困难；大规模的模块开发会非常的麻烦也容易出错；无特定语法支持，代码简陋。</p><h4 id="5、Module模式："><a href="#5、Module模式：" class="headerlink" title="5、Module模式："></a>5、Module模式：</h4><p>  广泛最初被定义的都是：传统软件工程中，一种为‘类’提供私有和公有封装的方法。<br>  最初的方式就是 IIFE 模式，随着业务的多元化、技术逐渐广泛，原来的模式已经满足不了需求了，</p><p>  所以模块化的规范慢慢浮出水面，以下广泛认可的模块化规范：<br>    &nbsp;&nbsp;CommonJS —服务端—（重点掌握）<br>    &nbsp;&nbsp;AMD —客户端(浏览器等)—（了解下即可）<br>    &nbsp;&nbsp;CMD —综合CJS和AMD—（了解下即可）<br>    &nbsp;&nbsp;UMD —多种规范综合—（了解下即可）<br>    &nbsp;&nbsp;ESModule —ES6—（重点掌握）</p><h2 id="怎么样模块化？（Module模式案例"><a href="#怎么样模块化？（Module模式案例" class="headerlink" title="怎么样模块化？（Module模式案例)"></a>怎么样模块化？（Module模式案例)</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>  简称：CJS。代表为 nodejs，作用于服务端；（浏览器环境中需 babel 等方式转码）<br><br>  导出与导入语法：<br>  &nbsp;导出：module.exports 和 exports（两者尽量不要混用）<br>    <!-- 1：模块只有一个出口，module.exports对象，需要把模块希望输出的内容放入该对象。    2：简化的导出方式，直接使用 exports ，效果与使用 module.exports 一样。 --></p><!-- （exports 是 module.exports 的一个引用。换句话说，exports 是 module.exports 的快捷方式。） --><p>  &nbsp;导入：require() 方法<br>    <!-- 该方法读取一个文件并且执行，返回文件内部的module.exports对象。 --></p><p>  CJS 案例——服务端实现（主作用）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>、下载安装 node.<span class="hljs-property">js</span><br><br><span class="hljs-number">2</span>、创建项目结构 打开终端命令： npm init  （创建的主目录含有-中文-会无法生成初始化）<br>|-modules  (创建目录与模块文件)<br>  |-module1.<span class="hljs-property">js</span>  <br>  |-module2.<span class="hljs-property">js</span>  <br>  |-module3.<span class="hljs-property">js</span><br>|-app.<span class="hljs-property">js</span> （创建入口模块文件）<br>|-package.<span class="hljs-property">json</span>     &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;commonJS-node&quot;</span>,    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>  &#125;<br><br><span class="hljs-number">3</span>、下载第三方模块 <br>  npm install uniq --save <span class="hljs-comment">// 用于数组去重</span><br><br><span class="hljs-number">4</span>、定义模块代码<br>  <span class="hljs-comment">//module1.js</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;module1&#x27;</span>, <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>) &#125;&#125;<br>  <span class="hljs-comment">//module2.js</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;module2&#x27;</span>) &#125;<br>  <span class="hljs-comment">//module3.js</span><br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">foo</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo() module3&#x27;</span>)&#125;<br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><br>  <span class="hljs-comment">// app.js 文件 引入第三方库，应该放置在最前面</span><br>    <span class="hljs-keyword">let</span> uniq = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uniq&#x27;</span>)                   <span class="hljs-comment">// 注意：核心模块可不需要路径</span><br>    <span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/module1&#x27;</span>)   <span class="hljs-comment">// 注意：模块文件可省略 .js</span><br>    <span class="hljs-keyword">let</span> module2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/module2&#x27;</span>)<br>    <span class="hljs-keyword">let</span> module3 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/module3&#x27;</span>)<br><br>    <span class="hljs-comment">// 终端输出</span><br>    module1.<span class="hljs-title function_">foo</span>()   <span class="hljs-comment">// module1</span><br>    <span class="hljs-title function_">module2</span>()       <span class="hljs-comment">// module2</span><br>    module3.<span class="hljs-title function_">foo</span>()   <span class="hljs-comment">// foo() module3</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniq</span>(module3.<span class="hljs-property">arr</span>))  <span class="hljs-comment">// [ 1, 2, 3 ]</span><br><br><span class="hljs-number">5</span>、通过 node ，命令行输入 node app.<span class="hljs-property">js</span> ，运行 <span class="hljs-variable constant_">JS</span> 文件<br></code></pre></td></tr></table></figure><br>  CJS 案例——浏览器端实现：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>、创建项目结构<br>  |-js  <br>      |-dist <span class="hljs-comment">//打包生成文件的目录（可打包命令时生成）  </span><br>      |-src <span class="hljs-comment">//源码所在的目录    </span><br>        |-module1.<span class="hljs-property">js</span>    <br>        |-module2.<span class="hljs-property">js</span>    <br>        |-module3.<span class="hljs-property">js</span>    <br>      |-app.<span class="hljs-property">js</span>    <span class="hljs-comment">//应用主源文件</span><br>  |-index.<span class="hljs-property">html</span>    <span class="hljs-comment">//渲染的模板文件 </span><br>  |-package.<span class="hljs-property">json</span>  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;browserify-test&quot;</span>,    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>  &#125;<br><br><span class="hljs-number">2</span>、下载第三方模块 uniq 和 browserify<br>  项目下：npm install uniq --save   用于数组去重<br>  全局: npm install browserify -g  （package.<span class="hljs-property">json</span>配置打包命令，可不用全局安装）<br>  局部: npm install browserify --save-dev<br><br><span class="hljs-number">3</span>、定义模块代码<br>  <span class="hljs-comment">//module1.js</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;module1&#x27;</span>, <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>) &#125;&#125;<br>  <span class="hljs-comment">//module2.js</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;module2&#x27;</span>) &#125;<br>  <span class="hljs-comment">//module3.js</span><br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">foo</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo() module3&#x27;</span>)&#125;<br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<br><br>  <span class="hljs-comment">// app.js 文件 引入第三方库，应该放置在最前面</span><br>    <span class="hljs-keyword">let</span> uniq = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uniq&#x27;</span>)<br>    <span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/module1&#x27;</span>)<br>    <span class="hljs-keyword">let</span> module2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/module2&#x27;</span>)<br>    <span class="hljs-keyword">let</span> module3 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./modules/module3&#x27;</span>)<br>  <br>    module1.<span class="hljs-title function_">foo</span>()   <span class="hljs-comment">// module1</span><br>    <span class="hljs-title function_">module2</span>()       <span class="hljs-comment">// module2</span><br>    module3.<span class="hljs-title function_">foo</span>()   <span class="hljs-comment">// foo() module3</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniq</span>(module3.<span class="hljs-property">arr</span>))  <span class="hljs-comment">// [ 1, 2, 3 ]</span><br><br><span class="hljs-number">4</span>、打包处理 js<br>  根目录下运行 browserify  js/src/app.<span class="hljs-property">js</span> -o js/dist/bundle.<span class="hljs-property">js</span> 打包命令<br>  （可在package.<span class="hljs-property">json</span>配置script，直接输入命令即可，也不需要全局安装模块包）<br>  如： package.<span class="hljs-property">json</span> 下配置<br>      <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;browserify js/src/app.js -o js/dist/bundle.js&quot;</span><br>      &#125;<br>    配置build后使用 npm run build 即可编译打包，否则使用打包命令<br><br><span class="hljs-number">5</span>、页面使用引入<br>  在 index.<span class="hljs-property">html</span> 文件中引入打包好的js文件，注意放置在 <span class="hljs-variable constant_">HTML</span> 页面底部 body 标签前<br>  &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;js/dist/bundle.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="AMD（异步模块定义-—-Asynchronous-Module-Definition）"><a href="#AMD（异步模块定义-—-Asynchronous-Module-Definition）" class="headerlink" title="AMD（异步模块定义 — Asynchronous Module Definition）"></a>AMD（异步模块定义 — Asynchronous Module Definition）</h3><p>其代表为 require.js（简称：RJ），仅供前端使用；<br>语法：通过define函数全局定义模块（导入和导出）<br>  &nbsp;&nbsp;define(id?,  dependencies?,  factory);<br>    <!-- —— id  可选，用来定义模块标识，如果未提供该参数，脚本文件名(去掉拓展名)    —— dependencies  可选，是一个导入模块的数组    —— factory 工厂方法（对象或函数）模块初始化要执行的， --></p>  <!--     如果是对象，则此对象将直接作为模块的导出，而不需要再定义一个函数来返回它；      define({          foo: 'bar',          doSomething: function() {              // 模块的方法          }        });  如果是函数，它将在依赖项加载完成后被调用，并接收依赖项的导出作为参数，    且模块可以通过以下三种方式对外暴漏：      API：return 任意类型；        exports.XModule = XModule；       module.exports = XModule。    define(['mo1', 'mo2'], function(m1, m2) {        // 模块的初始化逻辑        function doSomething() {            // 使用m1和m2的功能        }        // 返回模块的导出接口        return {            doSome: doSomething   // 使用doSome作导出接口      };      });   --><p>语法：下载 require.js库（只导入）<br>&nbsp;&nbsp;require(dependencies, callback);<br>    <!-- ——第一个参数是一个数组，表示所依赖的模块；    ——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。    --><br>  <!-- 例：require(['module1', 'module2'], function(m1, m2){} )  --></p><p>  AMD-RJ 案例——浏览器端实现（主作用）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>、创建项目结构<br>  |-js  <br>    |-libs    <br>      |-<span class="hljs-built_in">require</span>.<span class="hljs-property">js</span>  <br>      |-jquery.<span class="hljs-property">js</span>  需要第三方模块时<br>    |-modules    <br>      |-alerter.<span class="hljs-property">js</span>    <br>      |-dataService.<span class="hljs-property">js</span>  <br>    |-main.<span class="hljs-property">js</span><br>  |-index.<span class="hljs-property">html</span><br><br><span class="hljs-number">2</span>、下载 <span class="hljs-built_in">require</span>.<span class="hljs-property">js</span> 和 jquery.<span class="hljs-property">js</span> , 并将文件替换或代码写入上面目录结构的 <span class="hljs-built_in">require</span>.<span class="hljs-property">js</span> <br>  官网: <span class="hljs-attr">http</span>:<span class="hljs-comment">//www.requirejs.cn/  或  github : https://github.com/requirejs/requirejs</span><br><br><br><span class="hljs-number">3</span>、定义模块代码<br>  <span class="hljs-comment">// alerter.js 模块文件（定义引入第三方模块的文件）</span><br>    <span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;dataService&#x27;</span>, <span class="hljs-string">&#x27;jquery&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">dataService, $</span>) &#123;   <br>      <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Tom&#x27;</span>  <br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">showMsg</span>(<span class="hljs-params"></span>) &#123;   <br>        <span class="hljs-title function_">alert</span>(dataService.<span class="hljs-title function_">getMsg</span>() + <span class="hljs-string">&#x27;, &#x27;</span> + name)  <br>      &#125;  <br>      $(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>)  <span class="hljs-comment">// 暴露模块 (引入第三方模块使用) </span><br>      <span class="hljs-keyword">return</span> &#123; showMsg &#125;<br>    &#125;)<br><br>  <span class="hljs-comment">// main.js 文件 （定义引入配置第三方模块）</span><br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <br>      <span class="hljs-built_in">require</span>.<span class="hljs-title function_">config</span>(&#123;    <br>        <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">&#x27;js/&#x27;</span>,   <span class="hljs-comment">//基本路径 出发点在根目录下    </span><br>        <span class="hljs-attr">paths</span>: &#123;      <br>          <span class="hljs-comment">//自定义模块      </span><br>          <span class="hljs-attr">alerter</span>: <span class="hljs-string">&#x27;./modules/alerter&#x27;</span>,   <span class="hljs-comment">//此处不能写成 alerter.js,会报错      </span><br>          <span class="hljs-attr">dataService</span>: <span class="hljs-string">&#x27;./modules/dataService&#x27;</span>,      <br>          <span class="hljs-comment">// 第三方库模块      </span><br>          <span class="hljs-attr">jquery</span>: <span class="hljs-string">&#x27;./libs/jquery-3.7.1&#x27;</span>  <span class="hljs-comment">//注意：写成 jQuery 会报错（文件可自命名）   </span><br>        &#125;  <br>      &#125;)  <br>      <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;alerter&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">alerter</span>) &#123;    <br>        alerter.<span class="hljs-title function_">showMsg</span>()  <br>      &#125;)<br>    &#125;)()<br><br><span class="hljs-number">4</span>、页面引入 <span class="hljs-built_in">require</span>.<span class="hljs-property">js</span> 模块:<br>  在 index.<span class="hljs-property">html</span> 引入 &lt;script data-main=<span class="hljs-string">&quot;js/main&quot;</span> src=<span class="hljs-string">&quot;js/libs/require.js&quot;</span>&gt;&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="CMD（通用模块定义-直译-—-Common-Module-Definition）"><a href="#CMD（通用模块定义-直译-—-Common-Module-Definition）" class="headerlink" title="CMD（通用模块定义(直译) — Common Module Definition）"></a>CMD（通用模块定义(直译) — Common Module Definition）</h3><p>其代表为Sea.js（简称：SJ），仅供前端使用；<br>规范整合了 CommonJS 和 AMD 规范的特点。</p><!-- 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。 --><p> 语法：定义模块也是通过一个全局函数 define 来实现的，但只有一个参数，该参数可以是函数也可以是对象：<br>&nbsp;&nbsp;&nbsp;&nbsp;全局定义模块（导入和导出）define(factory);</p>  <!-- &nbsp;&nbsp;&nbsp;&nbsp;如果 factory 参数是对象那模块就导出对象，和AMD一样不需要再定义一个函数返回它； --><p>  &nbsp;&nbsp;&nbsp;&nbsp;如果 factory 参数是对象那模块就导出对象，一样不需要再定义一个函数返回它；<br>  &nbsp;&nbsp;&nbsp;&nbsp;如果 factory 参数为函数，那么这个函数会被传入 3 个参数，即：<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factory &#x3D; function (require, exports, module) { }</p><!-- // 对象将直接作为模块的导出  define({      foo: 'bar',      doSomething: function() {          // 模块的方法      }    });  如果这个 factory 参数为函数，那么这个函数会被传入 3 个参数，即：factory = function (require, exports, module) {}  参数  ① require    是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口；    即导入第二者，如 var m1 = require('m1')    当require参数为函数时；多项导入时，使用规范中定义的 require 参数作为函数也有两个参数：    require(dependencies?, callback);         参数定义         dependencies：依赖项数组；        callback：加载模块时执行的回调函数。    例：var a = require( ['m1.js','jquery', ...], function(){} )  ② exports    是一个对象，用来向外提供模块接口；    即导出本模块接口，如 exports.fun = a  ③ module    是一个对象，上面存储了与当前模块相关联的一些属性和方法。    这个对象包含 3 个属性：      uri：模块完整的 URI 路径；      dependencies：模块依赖；      exports：模块需要被导出的 API，作用同第二个参数 exports。    如 module.uri = './modules/a.js' ...  --><p> CMD-SJ 案例——浏览器端实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs text">1、下载 sea.js, 并引入<br>  官网:http://seajs.org/   或  github:https://github.com/seajs/seajs<br>  （然后将 sea.js 导入项目: js/libs/sea.js ）<br><br>2、创建项目结构<br>  |-js  <br>    |-libs    <br>      |-sea.js  <br>    |-modules    <br>      |-module1.js    <br>      |-module2.js    <br>      |-module3.js    <br>      |-module4.js    <br>    |-main.js<br>  |-index.html<br><br>3、定义使用 sea.js库 的模块代码<br>// module1.js 文件<br>define(function (require, exports, module) &#123;  <br>  var data = &#x27;atguigu.com&#x27;;  //内部变量数据  <br>  //内部函数  <br>  function show() &#123;    <br>    console.log(&#x27;module1 show() &#x27; + data)  <br>  &#125;  <br>  exports.show = show   //向外暴露  <br>&#125;)<br><br>// module2.js 文件<br>define(function (require, exports, module) &#123;  <br>  module.exports = &#123;    msg: &#x27;I Will Back&#x27;  &#125;<br>&#125;)<br><br>// module3.js 文件<br>define(function(require, exports, module) &#123;  <br>  const API_KEY = &#x27;abc123&#x27;  <br>  exports.API_KEY = API_KEY<br>&#125;)<br><br>// module4.js 文件<br>define(function (require, exports, module) &#123;  <br>  //引入依赖模块（同步)  <br>  var module2 = require(&#x27;./module2&#x27;)  <br>  function show() &#123;    <br>    console.log(&#x27;module4 show() &#x27; + module2.msg)  <br>  &#125;  <br>  exports.show = show   <br>  //引入依赖模块（异步)  <br>  require.async(&#x27;./module3&#x27;, function (m3) &#123;    <br>    console.log(&#x27;异步引入依赖模块 3  &#x27; + m3.API_KEY)  <br>  &#125;)<br>&#125;)<br><br>// main.js 文件（模块主入口文件）<br>define(function (require) &#123;  <br>  var m1 = require(&#x27;./module1&#x27;)  <br>  var m4 = require(&#x27;./module4&#x27;)  <br>  m1.show()  <br>  m4.show()<br>&#125;)<br><br>4、在 index.html 中引入<br>  &lt;!-- 使用sea.js导入 --&gt;<br>  &lt;script type=&quot;text/javascript&quot; src=&quot;js/libs/sea.js&quot;&gt;&lt;/script&gt;<br>  &lt;script type=&quot;text/javascript&quot;&gt;  <br>      seajs.use(&#x27;./js/modules/main&#x27;)<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="UMD（通用模块定义-确称-—-Universal-Module-Definition-）"><a href="#UMD（通用模块定义-确称-—-Universal-Module-Definition-）" class="headerlink" title="UMD（通用模块定义(确称) — Universal Module Definition ）"></a>UMD（通用模块定义(确称) — Universal Module Definition ）</h3><p>  统一&#x2F;通用模块定义规范，也是设计模式之一，让模块能在 JS 所有运行环境发挥作用，<br>  那就意味着模块的方式要同时满足CommonJS, AMD, CMD的标准。</p><p>一个 UMD 模块由两部分组成：<br>  &nbsp;&nbsp;立即调用函数表达式 (IIFE)：它会检查使用模块的环境。它有两个参数：<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;root 和 factory<br>  &nbsp;&nbsp;&nbsp;&nbsp;root 是对全局范围的 this 引用，而 factory 是定义模块的函数。<br>  &nbsp;&nbsp;匿名函数：创建模块，此匿名函数被传递任意数量的参数以指定模块的依赖关系。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs text">1、全局环境情况时<br>global文件夹 <br>  |-a.js<br>  |-index.html<br>// a.js<br>  (function (root, factory) &#123;<br>    console.log(&#x27;-----global环境--------&#x27;);<br>    root.z = factory();<br>  &#125;)(this, function () &#123;<br>    function fun() &#123;<br>      console.log(&quot;Hello!&quot;);<br>    &#125;<br>    return &#123;<br>      b: fun,<br>    &#125;;<br>  &#125;);<br><br>// index.html<br>  &lt;title&gt;global测试&lt;/title&gt;<br>  &lt;script src=&quot;./a.js&quot;&gt;&lt;/script&gt;<br>  &lt;script&gt;<br>    z.b();<br>  &lt;/script&gt;<br><br><br>2、CJS、AMD、CMD等模块环境时<br>//a.js（通用-各自环境中导入）<br>(function (root, factory) &#123;<br>  if(typeof exports === &#x27;object&#x27; &amp;&amp; typeof module !== &#x27;undefined&#x27;) &#123;<br>    console.log(&quot;-----commonJS环境--------&quot; );<br>    module.exports = factory();<br>  &#125; else if(typeof define === &#x27;function&#x27; &amp;&amp; define.cmd) &#123;<br>    console.log(&#x27;-----CMD环境--------&#x27;);<br>    define([], factory);<br>  &#125;else if(typeof define === &#x27;function&#x27; &amp;&amp; define.amd) &#123;<br>    console.log(&#x27;-----AMD环境--------&#x27;);<br>    define([], factory);<br>  &#125;else &#123;<br>    console.log(&#x27;-----global环境--------&#x27;);<br>    root.Hello = factory();      <br>  &#125;<br>&#125;)(this, function () &#123;<br>    function fun() &#123;<br>      console.log(&quot;Hello!&quot;);<br>    &#125;<br>    return &#123;<br>      b: fun,<br>    &#125;;<br>&#125;);<br><br><br>// CJS导入情况时<br>CommonJS文件夹<br>  |-a.js<br>  |-index.js<br><br>// index.js<br>  const &#123; b &#125; = require(&quot;./a&quot;);<br>  b()<br><br><br>// AMD导入情况时<br>AMD文件夹 <br>  |-js<br>      |-a.js<br>      |-index.js<br>  |-index.html<br><br>// index.js<br>  define(&#x27;index&#x27;,[&#x27;hello&#x27;], function(e) &#123;<br>      e.sayHello();<br>  &#125;);<br><br>// index.html<br>&lt;title&gt;AMD加载UMD&lt;/title&gt;<br>&lt;!-- 引入本地 AMD 模块化的 RequireJS 模块加载器 --&gt;<br>&lt;script src=&quot;https://requirejs.org/docs/release/2.3.6/minified/require.js&quot;&gt;&lt;/script&gt;<br><br>&lt;!-- 引入配置和入口脚本 --&gt;<br>&lt;script&gt;<br>  require.config(&#123;<br>    baseUrl: &quot;js/&quot;, // 设置基准路径<br>    paths: &#123;<br>      a: &quot;a&quot;, // 不需要写.js后缀<br>      index: &quot;index&quot;,<br>    &#125;,<br>  &#125;);<br><br>  // 启动应用<br>  require([&quot;index&quot;]);<br>&lt;/script&gt;<br><br><br>// CMD导入情况时<br>CMD文件夹 <br>  |-js<br>    |-a.js<br>    |-index.js<br>  |-index.html<br><br>// index.js<br>define(function(require, exports, module) &#123;<br>  var Hello= require(&#x27;a&#x27;);<br>  Hello.sayHello()   <br><br>  console.log(&#x27;hello-world&#x27;);<br>&#125;);<br><br>// index.html<br>&lt;title&gt;CMD加载UMD&lt;/title&gt;<br>&lt;!-- 引入 CMD 模块化的 SJ 模块加载器 --&gt;<br>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/seajs/3.0.3/sea.js&quot;&gt;&lt;/script&gt;<br><br>&lt;!-- 引入配置和入口脚本 --&gt;<br>&lt;script&gt;<br>  seajs.config(&#123;<br>    base: &quot;./js&quot;,<br>    alias: &#123;<br>      a: &quot;a&quot;, // 不需要写.js后缀<br>      index: &quot;index&quot;<br>    &#125;,<br>  &#125;);<br><br>  // 启动应用<br>  seajs.use(&quot;index&quot;);<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="ECMAScript-Modules（ES-Module）"><a href="#ECMAScript-Modules（ES-Module）" class="headerlink" title="ECMAScript Modules（ES Module）"></a>ECMAScript Modules（ES Module）</h3><p>  简称：ESM（也称：ES或ES6模块）。代表为node.js。也是目前前端开发最流行的模块化方案。它是 JavaScript 语言标准模块系统，旨在成为浏览器和服务器通用的模块系统。<br>  ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p><p>  CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。<br>  而 ES6 模块则是通过静态分析确定模块的依赖关系，以及输入和输出的变量。</p><p>  ES6 模块与模块化规范相比，有两个重要特点：<br>  &nbsp;&nbsp;&nbsp;&nbsp;模块化规范是运行时加载，ES6 模块是编译时输出接口。<br>  &nbsp;&nbsp;&nbsp;&nbsp;模块化规范输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p><p>  基本的导出与导入语法：<br>  &nbsp;&nbsp;&nbsp;&nbsp;导出语法：export default 与 export        （注意 exports 是 CJS 的导出）<br>  &nbsp;&nbsp;&nbsp;&nbsp;导入语法：import </p><p>导出语法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">export default：一个模块只能一个关键词导出。（默认导出）<br>  对应 import 导入可使用 不带&#123;&#125; 的任意变量来接收<br>export：一个模块可多个关键词导出。（命名导出）<br>  对应 import 导入要使用 带&#123;&#125; 的同名变量来接收<br><br>export default 默认导出方式：<br>  export default function 函数名() &#123;&#125;<br>  export default class 类名 &#123;&#125;<br>  export default 变量名;<br><br>  注意：一个模块只能有一个默认导出，不能有多个。<br><br>export 命名导出方式：<br>  export const 变量名 = 值;<br>  export let 变量名 = 值;<br>  export var 变量名 = 值;<br>  export function 函数名() &#123;&#125;<br>  export class 类名 &#123;&#125;<br><br>注意：命名导出可以导出多个成员，可以与默认导出一起使用。<br><br><br>目前 export 命令能够对外输出的就是三种接口：<br>  函数（Functions）， 类（Classes），var、let、const 声明的变量（Variables）。<br></code></pre></td></tr></table></figure><br>导入语法：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs text">import 常规导入语法：<br>  import 模块名 from &#x27;模块路径&#x27;<br>  import &#123; 成员1, 成员2 &#125; from &#x27;模块路径&#x27;<br>  import &#123; 成员1 as 别名1, 成员2 as 别名2 &#125; from &#x27;模块路径&#x27;<br>  import 模块名 from &#x27;模块路径&#x27;，模块名 as 别名<br>  import 模块名 from &#x27;模块路径&#x27;，模块名 as 别名，成员1，成员2<br><br>  impor * as 别名 from &#x27;模块路径&#x27;<br>    <br>模块导入的其它方式：import() 函数：<br>  （因为require是运行时加载模块，import命令无法取代require的动态加载功能。）<br>  import(&#x27;模块路径&#x27;).then(module =&gt; &#123;<br>    // 使用模块<br>  &#125;);<br><br>注意：import()函数是异步加载模块，它返回一个 Promise 对象，所以需要使用then()方法指定处理函数。<br><br>异步导入语法：    <br>  import(&#x27;模块路径&#x27;).then(module =&gt; &#123;<br>    // 使用模块<br>  &#125;).catch(error =&gt; &#123;<br>    // 处理加载失败的情况<br>  &#125;);<br><br>由于考虑到代码的清晰，更推荐使用await命令。<br><br>async function renderWidget() &#123;<br>  const container = document.getElementById(&#x27;widget&#x27;);<br>    if (container !== null) &#123;<br>      // 等同于<br>      // import(&quot;./widget&quot;).then(widget =&gt; &#123;<br>      //   widget.render(container);<br>      // &#125;);<br>      const widget = await import(&#x27;./widget.js&#x27;);<br>      widget.render(container);<br>    &#125;<br>&#125;<br><br>renderWidget();<br><br></code></pre></td></tr></table></figure><br><p>模块文件可直接在node.js中运行，一般在node环境直接使用命令：node xxx.js 运行。<br>而在浏览器中，esm模块需要通过打包工具（如webpack）打包成浏览器可识别的模块格式。</p><br><span style="color:red">ES模块化浏览器端实现：<br> &nbsp;&nbsp;(。。。例：使用 webpack + babel 打包编译构建 ES6 转码到(旧)浏览器等使用，请查看下一篇案例。。。 )</span><br><br><h2 id="为什么要模块化？"><a href="#为什么要模块化？" class="headerlink" title="为什么要模块化？"></a>为什么要模块化？</h2><p>前端模块化的意义在于提高代码的复用性、可读性、可维护性以及降低各部分之间的耦合度。<br></p><p>1、使系统的未来有扩展性；<br><br>2、提高代码的持续可维护性；<br><br>3、促进代码可以复用；<br><br>4、并行开发简化团队协作；<br><br>5、提高代码的可测试性；<br><br>6、提供懒加载和按需加载的架构；<br><br>7、更好的封装和隐藏实现细节；<br><br>…</p><p>所以，也从案例上了解到业务项目的模块化是必须的、必要的，也是大势所趋…</p><p><br><br><br><br><br>（待续…）<br><br><br><br>注：</p><p style="font-size: 8px">    部分资源转载于：<br>    <a href="https://blog.csdn.net/DengZY926/article/details/138804724" style="color: black;">dengzhanyong：https://blog.csdn.net/DengZY926/...</a><br></p><br><p style="font-size: 10px">注：<br>本站商业转载需<a href="https://email.163.com/">联系博主:wyyx9082hgl@163.com</a>授权，非商业转载请注明出处。<br>    无法联系博主请在评论区注明，未经授权或无联系方式相关法律责任问题将追究。</p><p style="font-size: 10px">    本站为学习交流使用，非商业用途。如有资源侵权请<a href="https://email.163.com/">[联系博主]</a>，感谢您的支持！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前后端</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端设计模式</title>
    <link href="/tomnyblog.github.io/2024/05/03/Zfront-end_design-pattern/"/>
    <url>/tomnyblog.github.io/2024/05/03/Zfront-end_design-pattern/</url>
    
    <content type="html"><![CDATA[<p>什么是前端设计模式？包括哪些模式？</p><span id="more"></span><p>设计模式不只是前端，也适用任何开发人员的学习与思考；当然，前端方面需要些基础才能更好深入学习，比如了解面向对象编程(OOP)、函数式编程、了解框架与库和工程化模块化组件化开发…等等~~  <br></p><h2 id="什么是前端设计模式？"><a href="#什么是前端设计模式？" class="headerlink" title="什么是前端设计模式？"></a>什么是前端设计模式？</h2><p>前端设计模式是什么？前端设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结；拆开来讲，首先前端设计这个就容易理解了，比如项目需要的N个页面、各种页面的样式和排版、界面的各种交互与和逻辑操作…等等；<br>再来理解模式，这个有些说法了，与其说模式，大都开发人员广泛的认为是一种方案，只不过多种模式多种方案罢了；既然设计模式是解决问题的方案，也就是多种模式多种解决问题的办法了。同样的问题可以不同的办法，不同的问题也有相同或不同的办法，所以设计模式也是一种思想，一种思维的艺术…<br></p><h2 id="前端设计包括哪些模式？"><a href="#前端设计包括哪些模式？" class="headerlink" title="前端设计包括哪些模式？"></a>前端设计包括哪些模式？</h2><p>本文的设计模式包括五种：创建型、结构型、行为型、技巧型和架构型；<br><br>细分目录：<br><span style="color:blue">创建型设计模式：</span><span style="font-size:14px">简单工厂模式；工厂方法模式；抽象工厂模式；建造者模式；原型模式；单例模式。</span><br><span style="color:blue">结构型设计模式：</span><span style="font-size:14px">外观模式；适配器模式；代理模式；装饰者模式；桥接模式；组合模式；享元模式。</span><br><span style="color:blue">行为型设计模式：</span><span style="font-size:14px">模板方法模式；观察者模式；状态模式；策略模式；职责链模式；命令模式；访问者模式；中介者模式；备忘录模式；迭代器模式；解释器模式。</span><br><span style="color:blue">技巧型设计模式：</span><span style="font-size:14px">链模式；委托模式；数据访问对象模式；节流模式；简单模板模式；惰性模式；参与者模式；等待者模式。</span><br><span style="color:blue">架构型设计模式：</span><span style="font-size:14px">同步模块模式；异步模块模式；组件化开发模式；Widget模式；前端路由模式；响应式设计模式；MVC模式；MVP模式；MVVM模式。</span></p><br><!-- <span style="color:red"></span> --><h2 id="一、创建型设计模式-—-处理对象的创建，控制对象创建时设计的问题或复杂度"><a href="#一、创建型设计模式-—-处理对象的创建，控制对象创建时设计的问题或复杂度" class="headerlink" title="一、创建型设计模式 — 处理对象的创建，控制对象创建时设计的问题或复杂度"></a><span style="color:blue">一、创建型设计模式 — 处理对象的创建，控制对象创建时设计的问题或复杂度</span></h2><h3 id="1、简单工厂模式（Simple-Factory）"><a href="#1、简单工厂模式（Simple-Factory）" class="headerlink" title="1、简单工厂模式（Simple Factory）"></a>1、简单工厂模式（Simple Factory）</h3><p><span style="color:red">简单工厂模式：</span>又称静态工厂方法模式，但不属于GOF设计模式（Gang of Four设计模式）之一，是由一个工厂对象决定创建出哪一种产品类的实例，也是工厂模式家族中最简单实用的模式。<br><br><span style="color:red">场景：</span>当需要创建的对象较少且不会频繁增加时。<br><br><span style="color:red">优点：</span>客户端不需要知道具体产品的类名，只需要知道对应的工厂类和产品类型。<br><span style="color:red">缺点：</span>当产品种类增加时需要修改工厂类的判断逻辑，违反了开闭原则。<br><br></p><h3 id="2、工厂方法模式（Factory-Method）"><a href="#2、工厂方法模式（Factory-Method）" class="headerlink" title="2、工厂方法模式（Factory Method）"></a>2、工厂方法模式（Factory Method）</h3><p><span style="color:red">工厂方法模式：</span>也称虚拟构造器模式(Virtual Constructor)或者多态工厂模式(Polymorphic Factory)，定义一个接口用于创建对象，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。<br><br><span style="color:red">场景：</span>适用于创建具有不同构造过程的对象，需要在运行时根据不同条件创建对象，并具体类的实例化需要延迟到子类时。例如连接池、不同类型的日志记录器（如文件日志记录器、数据库日志记录器等）。<br><br><span style="color:red">优点：</span>符合开闭原则，增加新产品时无需修改工厂接口和客户端代码，只需添加新的具体产品类和具体工厂类。<br><span style="color:red">缺点：</span>但每增加一个产品，就需要增加一个具体产品类和一个具体工厂类，增加了系统的复杂度。<br><br></p><h3 id="3、抽象工厂模式（Abstract-Factory）"><a href="#3、抽象工厂模式（Abstract-Factory）" class="headerlink" title="3、抽象工厂模式（Abstract Factory）"></a>3、抽象工厂模式（Abstract Factory）</h3><p><span style="color:red">抽象工厂模式：</span>提供接口——用于创建一系列相关或相互依赖的对象而无需指定它们具体的类（即对类的工厂抽象使业务对产品类簇的创建而不负责创建某一类产品的实例）。可以看作是工厂方法模式的泛化，它允许创建多个对象族。<br><br><span style="color:red">场景：</span>创建具有相互依赖关系的对象族。例如，跨平台（如 Windows、macOS、Linux）的 GUI 工具箱（如相关的组件）或 UI 组件的跨平台开发。<br><br><span style="color:red">优点：</span>增加新的产品族时，无需修改已有系统，符合开闭原则，同时可保证客户端始终只使用同一个产品族中的对象。<br><span style="color:red">缺点：</span>增加新的产品等级结构时，需要修改抽象工厂接口及其所有子类，较为不便。<br><br></p><h3 id="4、建造者模式（Builder）"><a href="#4、建造者模式（Builder）" class="headerlink" title="4、建造者模式（Builder）"></a>4、建造者模式（Builder）</h3><p><span style="color:red">建造者模式：</span>（Java模式也称生成器模式）某复杂对象的创建层和表示层的分离，同样的构建过程创建不同的表示。<br><br><span style="color:red">场景：</span>当创建对象的构建过程比较复杂，且需要创建不同表示时。<br><br><span style="color:red">优点：</span>客户端不必知道产品内部组成的细节，只需通过建造者接口来指定产品的类型和内容。<br><span style="color:red">缺点：</span>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类。<br><br></p><h3 id="5、原型模式（Prototype）"><a href="#5、原型模式（Prototype）" class="headerlink" title="5、原型模式（Prototype）"></a>5、原型模式（Prototype）</h3><p><span style="color:red">原型模式：</span>用原型实例指向创建对象的种类，创建新对象的类可以通过拷贝来共享原型已创建对象的属于或方法。<br><br><span style="color:red">场景：</span>大量相似的对象，如编辑器中的图形工具。<br><br><span style="color:red">优点：</span>特别创建复杂对象时性能较好；同时可以动态地增加或删除对象的属性。<br><span style="color:red">缺点：</span>需要为每一个类配备一个克隆方法，且深拷贝的实现较为复杂。<br><br></p><h3 id="6、单例模式（Singleton）"><a href="#6、单例模式（Singleton）" class="headerlink" title="6、单例模式（Singleton）"></a>6、单例模式（Singleton）</h3><p><span style="color:red">单例模式：</span>也称为单体模式，一个类只能一个实例，且有一个全局访问点。<br><br><span style="color:red">场景：</span>当一个类只需要一个实例来协调操作时，如配置管理器、资源管理器等。<br><br><span style="color:red">优点：</span>减少内存开销，避免对共享资源的多重占用。<br><span style="color:red">缺点：</span>单例模式一般没有接口，扩展困难；若单例对象大量数据可能成为系统的瓶颈。</p><p><br><br></p><h2 id="二、结构型设计模式-—-简化-类或对象-组成大而复杂结构"><a href="#二、结构型设计模式-—-简化-类或对象-组成大而复杂结构" class="headerlink" title="二、结构型设计模式 — 简化(类或对象)组成大而复杂结构"></a><span style="color:blue">二、结构型设计模式</span> — 简化(类或对象)组成大而复杂结构</h2><h3 id="7、外观模式（Facade-Pattern）"><a href="#7、外观模式（Facade-Pattern）" class="headerlink" title="7、外观模式（Facade Pattern）"></a>7、外观模式（Facade Pattern）</h3><p><span style="color:red">外观模式：</span>将子系统复杂接口统一提供一个接口，来更方便使用子系统。<br><br><span style="color:red">场景：</span>客户端需要访问多个子系统，但又不想直接依赖这些子系统时；或者只想一个接口就能使用多个子系统时。<br><br><span style="color:red">优点：</span>封装子系统复杂性，为客户端提供一个简单接口，降低系统的耦合度。<br><span style="color:red">缺点：</span>如果设计的接口过于复杂，可能会违反单一职责原则。<br><br></p><h3 id="8、适配器模式（Adapter-Pattern）"><a href="#8、适配器模式（Adapter-Pattern）" class="headerlink" title="8、适配器模式（Adapter Pattern）"></a>8、适配器模式（Adapter Pattern）</h3><p><span style="color:red">适配器模式：</span>解决对象(或类)之间接口的不兼容性，即将接口转化成另一个接口。<br><br><span style="color:red">场景：</span>替换依赖的系统或库来兼容新的接口；适配不同的数据能在同一系统使用，如数据格式，接口设计成一种数据格式统一多种不同的数据源格式。<br><br><span style="color:red">优点：</span>不兼容的接口可转换为可兼容的接口，提高代码复用性和灵活性。<br><span style="color:red">缺点：</span>过多使用适配器可能会导致代码中的方法调用变得复杂和难以理解。<br><br></p><h3 id="9、代理模式（Proxy-Pattern）"><a href="#9、代理模式（Proxy-Pattern）" class="headerlink" title="9、代理模式（Proxy Pattern）"></a>9、代理模式（Proxy Pattern）</h3><p><span style="color:red">代理模式：</span>也称委托模式，例如充当中介，作为目标对象有相同功能或作用的接口供第三者对象使用（即控制第三者对目标对象的拒绝或允许使用对象。<br><br><span style="color:red">场景：</span>业务系统中开发非功能性需求，如监控、统计、鉴权、限流等；用于客户端和服务器之间进行通信的远程代理；用于控制资源加载和初始的虚拟代理化，如图片懒加载、客户端请求服务端跨域资源。<br><br><span style="color:red">优点：</span>不改变原始类代码时通过引入代理类来给原始类附加功能，增强代码灵活性。<br><span style="color:red">缺点：</span>静态代理需要为每个被代理类创建一个代理类，可能类文件数量过多导致增加维护难度，动态代理虽然可以解决这一问题，但可能带来一些性能开销。<br><br></p><h3 id="10、装饰者模式（Decorator-Pattern）"><a href="#10、装饰者模式（Decorator-Pattern）" class="headerlink" title="10、装饰者模式（Decorator Pattern）"></a>10、装饰者模式（Decorator Pattern）</h3><p><span style="color:red">装饰者模式：</span>不改变(原对象)原类文件和使用继承的基础上，动态地包装扩展对象功能（添加属性或方法）。<br><br><span style="color:red">场景：</span>通过嵌套多个装饰器类来解决原始类在多个方向上功能扩展的问题，或给原对象添加格外的职责又不想用继承来扩展类的功能时。<br><br><span style="color:red">优点：</span>能动态给对象添加额外职责从而灵活的生成子类，且装饰者和被装饰者可以独立扩展，不会相互耦合。<br><span style="color:red">缺点：</span>装饰者过多可能导致类层次结构变得复杂。<br><br></p><h3 id="11、桥接模式（Brideg）"><a href="#11、桥接模式（Brideg）" class="headerlink" title="11、桥接模式（Brideg）"></a>11、桥接模式（Brideg）</h3><p><span style="color:red">桥接模式：</span>又称为柄体(Handle and Body)模式或接口(interface)模式，多个维度变化的同时完成不增加复杂度的解耦（即将抽象部分与实现部分脱耦，两个部分可以独立变化(各自组合或扩展)）。<br><br><span style="color:red">场景：</span>组件化开发，如React、‌Vue等将组件的外观（元素样式）和行为可以独立变化，‌而不会影响到其他部分的实现；独立变化的维度，如在图形绘制系统中，‌可以将形状和颜色的实现分离。<br><br><span style="color:red">优点：</span>解耦实现抽象和实现之间的绑定关系且各自维度变化灵活；两个变化的维度中任意扩展一个维度，‌不需要修改原有系统，‌符合开闭原则；因多层继承方案违背了单一职责原则、复用性差和类的个数多，可作为一个替代方案避免多层继承的缺点；实现细节对客户端透明，‌可以对用户隐藏实现细节。<br><span style="color:red">缺点：</span>增加系统的理解与设计难度，因为关联关系建立在抽象层，‌要求开发一开始就针对抽象层进行设计与编程；适用范围有一定的局限性。<br><br></p><h3 id="12、组合模式（Composite-Pattern）"><a href="#12、组合模式（Composite-Pattern）" class="headerlink" title="12、组合模式（Composite Pattern）"></a>12、组合模式（Composite Pattern）</h3><p><span style="color:red">组合模式：</span>又叫做部分-整体模式，使得用户对单个对象和组合对象的使用具有一致性。<br><br><span style="color:red">场景：</span>需要表示对象的部分-整体层次结构时。希望客户端可以忽略组合对象与单个对象的差异时。<br><br><span style="color:red">优点：</span>客户端可以一致地处理单个对象和组合对象，复杂对象清晰地定义层次，而且符合开闭原则。<br><span style="color:red">缺点：</span>设计时需要考虑到组合对象与单个对象的差异，且在运行时进行类型检查可能会变得复杂。<br><br></p><h3 id="13、享元模式（Flyweight-Pattern）"><a href="#13、享元模式（Flyweight-Pattern）" class="headerlink" title="13、享元模式（Flyweight Pattern）"></a>13、享元模式（Flyweight Pattern）</h3><p><span style="color:red">享元模式：</span>运用共享技术有效的支持大量细粒度的对象，避免对象间因有相同内容造成多余的内存开销。<br><br><span style="color:red">场景：</span>当系统中存在大量重复对象时，通过共享实例减少内存占用。在需要频繁创建和销毁对象的场景中，如渲染大量相似图形的游戏或图形应用程序。<br><br><span style="color:red">优点：</span>通过共享技术有效地减少了内存使用。<br><span style="color:red">缺点：</span>若对象的状态频繁变化，可能会增加额外的开销来维护状态的一致性。<br></p><p><br><br></p><h2 id="三、行为型设计模式-—-实现职责划分或算法抽象的交流"><a href="#三、行为型设计模式-—-实现职责划分或算法抽象的交流" class="headerlink" title="三、行为型设计模式 — 实现职责划分或算法抽象的交流"></a><span style="color:blue">三、行为型设计模式</span> — 实现职责划分或算法抽象的交流</h2><h3 id="14、模板方法模式（Template-Method-Pattern）"><a href="#14、模板方法模式（Template-Method-Pattern）" class="headerlink" title="14、模板方法模式（Template Method Pattern）"></a>14、模板方法模式（Template Method Pattern）</h3><p><span style="color:red">模板方法模式：</span>定义了一个算法的骨架，将一些步骤的实现延迟到子类中。在模板方法中，父类定义了一个模板方法，该方法包含了算法的骨架，而具体的实现细节由子类来完成。（即做好一个算法模板骨架的方法，其子类使用方法按照规定的骨架）。<br><br><span style="color:red">场景：</span>当算法的整体步骤很固定，但其中个别部分易变时，可以使用模板方法模式将容易变的部分抽象出来，供子类实现；需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。比如，项目所有提示框样式一致、所有按钮一样字体大小。<br><br><span style="color:red">优点：</span>将算法的公共部分提取到抽象模板中，避免每个具体类中重复的相同代码。<br><span style="color:red">缺点：</span>每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象；父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度。<br><br></p><h3 id="15、观察者模式（Observer-Pattern）"><a href="#15、观察者模式（Observer-Pattern）" class="headerlink" title="15、观察者模式（Observer Pattern）"></a>15、观察者模式（Observer Pattern）</h3><p><span style="color:red">观察者模式：</span>又被称发布-订阅者模式或消息机制，某个对象（主题&#x2F;被观察者）状态发生变化时，所有该对象的关注者（观察者）均能收到状态变化通知，以进行相应的处理。<br><br><span style="color:red">场景：</span>实现事件驱动系统，如用户提交订单后通知库存管理系统减少库存、通知支付系统进行支付操作等。实现发布-订阅模式，其中发布者发布消息，而多个订阅者订阅并接收消息。<br><br><span style="color:red">优点：</span>实现对象间松耦合，主题对象和观察者对象之间相互独立，可以根据需求增加或删除观察者，而不需要修改主题对象；支持广播通信，主题对象的状态变化会通知所有的观察者。<br><span style="color:red">缺点：</span>观察者数量过多会导致系统性能下降，且观察者之间的依赖关系复杂会导致系统难以维护。<br><br></p><h3 id="16、状态模式（State-Pattern）"><a href="#16、状态模式（State-Pattern）" class="headerlink" title="16、状态模式（State Pattern）"></a>16、状态模式（State Pattern）</h3><p><span style="color:red">状态模式：</span>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。<br><br><span style="color:red">场景：</span>一个操作中含有庞大的多分支结构，并且这些分支依赖于该对象的状态时。当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时。比如，在网上投票评选征集的图片。<br><br><span style="color:red">优点：</span>可以避免使用大量的if-else语句；减少了对象间的相互依赖；封装了转换规则，增加了新的状态很容易。<br><span style="color:red">缺点：</span>类与状态有关的方法会很多，造成类膨胀；增加了系统的复杂性和运行时的开销。<br><br></p><h3 id="17、策略模式（Strategy-Pattern）"><a href="#17、策略模式（Strategy-Pattern）" class="headerlink" title="17、策略模式（Strategy Pattern）"></a>17、策略模式（Strategy Pattern）</h3><p><span style="color:red">策略模式：</span>定义了一系列算法，并将它们一个个封装起来，使它们可以相互替换。此模式让算法的变化独立于使用算法的客户。<br><br><span style="color:red">场景：</span>当一个类在运行时需要改变它的行为时。一个系统需要动态地在几种算法中选择一种。当一个应用程序需要很好地支持算法或者策略的自由切换、扩展时。<br><br><span style="color:red">优点：</span>算法可以自由切换，符合开闭原则；避免使用多重条件判断。<br><span style="color:red">缺点：</span>策略类会增多而且所有策略类都需要对外暴露。<br><br></p><h3 id="18、职责链模式（Chain-of-Responsibility-Pattern）"><a href="#18、职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="18、职责链模式（Chain of Responsibility Pattern）"></a>18、职责链模式（Chain of Responsibility Pattern）</h3><p><span style="color:red">职责链模式：</span>定义了一种处理请求的方式，它让多个处理对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。<br><br><span style="color:red">场景：</span>处理对象不确定，需要动态指定处理对象。多个处理对象可以处理同一个请求，但处理对象的顺序可能不同。处理对象的数量和顺序可以动态变化。比如常用于日志记录、权限验证、请求过滤等场景。<br><br><span style="color:red">优点：</span>可动态增加或删除处理对象，方便系统的维护和升级；可对请求进行灵活处理，提高系统的可用性和性能；降低对象间耦合度，提高代码灵活性和可扩展性。<br><span style="color:red">缺点：</span>系统性能受到责任链长度和处理对象数量的影响，所以可能存在请求不能被处理的情况，需要在责任链的末端添加默认处理对象。<br><br></p><h3 id="19、命令模式（Command-Pattern）"><a href="#19、命令模式（Command-Pattern）" class="headerlink" title="19、命令模式（Command Pattern）"></a>19、命令模式（Command Pattern）</h3><p><span style="color:red">命令模式：</span>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<br><br><span style="color:red">场景：</span>需要将发送者和接收者解耦时，可以使用命令模式。例如，在智能家居系统中，用户通过遥控器向设备发送命令。<br><br><span style="color:red">优点：</span>降低了系统的耦合度，提高了系统的灵活性。<br><span style="color:red">缺点：</span>增加了一些类的开销，如命令对象等。<br><br></p><h3 id="20、访问者模式（Visitor-Pattern）"><a href="#20、访问者模式（Visitor-Pattern）" class="headerlink" title="20、访问者模式（Visitor Pattern）"></a>20、访问者模式（Visitor Pattern）</h3><p><span style="color:red">访问者模式：</span>作用于某对象结构中的元素，定义（不改变该对象而访问结构中元素）的新方法。<br><br><span style="color:red">场景：</span>需要对一个对象结构中的对象进行很多不同操作（操作间无关联），同时要避免让这些操作“污染”这些对象的类。如，一个系统有比较稳定的数据结构，但功能需求经常变化，这时使用访问者模式可以方便地添加新的访问者，而不需要修改原有的数据结构。<br><br><span style="color:red">优点：</span>解决了数据结构和操作之间的耦合性问题；易于增加新的操作，只需增加一个新的访问者类即可，符合开闭原则（对扩展开放，对修改关闭）；每个访问者类只负责一种操作（符合单一职责原则）。<br><span style="color:red">缺点：</span>数据结构发生变化，可能需要修改访问者类；元素类发生变化（如增加或减少属性），相应的访问者类也需要进行修改。<br><br></p><h3 id="21、中介者模式（Mediator-Pattern）"><a href="#21、中介者模式（Mediator-Pattern）" class="headerlink" title="21、中介者模式（Mediator Pattern）"></a>21、中介者模式（Mediator Pattern）</h3><p><span style="color:red">中介者模式：</span>定义了一个中介对象来封装一系列的对象交互，使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><br><span style="color:red">场景：</span>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解时。例如，在MVC模式中，控制器（Controller）就是模型（Model）和视图（View）的中介者，负责它们之间的交互。<br><br><span style="color:red">优点：</span>将一对多转化为一对一（降低程序复杂度）；实现类之间的解耦，使各个对象间不再直接相互引用，而是通过中介者进行交互，故也很方便地增加新的客户类。<br><span style="color:red">缺点：</span>中介者数量过多，‌可能会导致系统的复杂性增加。<br><br></p><h3 id="22、备忘录模式（Memento-Pattern）"><a href="#22、备忘录模式（Memento-Pattern）" class="headerlink" title="22、备忘录模式（Memento Pattern）"></a>22、备忘录模式（Memento Pattern）</h3><p><span style="color:red">备忘录模式：</span>(在Gof中又叫做快照模式（Snapshot Pattern）或Token模式)，在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。（即捕获和恢复对象内部状态，实现撤销和恢复功能,或者保存用户操作的历史记录）<br><br><span style="color:red">场景：</span>可以保存表单数据的历史记录，‌以便用户可以查看和恢复之前的数据状态；可以在使用前端应用时进行操作来保存操作前的状态，‌以便用户可以撤销操作并恢复到之前的状态；如游戏中的存档和读档功能（状态恢复）；如Word中的撤销（Ctrl+Z）功能（撤销操作）。‌<br><br><span style="color:red">优点：</span>能封装对象的状态信息便于后续恢复；为用户提供一种可恢复机制，提高软件灵活性和容错性；过保存对象状态的“快照”，可以快速恢复到某一特定状态。<br><span style="color:red">缺点：</span>会额外占用磁盘或内存等资源，尤其是在频繁使用备忘录功能时。<br><br></p><h3 id="23、迭代器模式（Iterator-Pattern）"><a href="#23、迭代器模式（Iterator-Pattern）" class="headerlink" title="23、迭代器模式（Iterator Pattern）"></a>23、迭代器模式（Iterator Pattern）</h3><p><span style="color:red">迭代器模式：</span>不暴露对象内部结构的同时，可顺序访问聚合对象内部元素的表示。<br><br><span style="color:red">场景：</span>提供统一遍历不同集合结构的方式；需要访问集合对象的内容，但又不希望暴露其内部表示时。<br><br><span style="color:red">优点：</span>外部代码可以透明地访问（抽象出来的集合对象的遍历行为）的内部数据（分离遍历行为）；为遍历不同的集合结构提供统一接口。<br><span style="color:red">缺点：</span>增加一个集合类就需要增加一个对应的迭代器类，增加了系统的复杂性。<br><br></p><h3 id="24、解释器模式（Interpreter-Pattern）"><a href="#24、解释器模式（Interpreter-Pattern）" class="headerlink" title="24、解释器模式（Interpreter Pattern）"></a>24、解释器模式（Interpreter Pattern）</h3><p><span style="color:red">解释器模式：</span>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。<br><br><span style="color:red">场景：</span>当需要定义一种简单的自定义语言，并为其创建解释器时（自定义语言）；特定类型问题发生频率足够高：如日志处理，当需要处理大量格式不同的日志时，可以使用解释器模式来解析这些日志。<br><br><span style="color:red">优点：</span>容易改变和扩展“语言”的表示；通过定义不同的解释器类，可以灵活地处理不同的语法规则。<br><span style="color:red">缺点：</span>语法规则都需要一个对应类而过多会增加系统的复杂度。<br></p><p><br><br></p><h2 id="四、技巧型设计模式-—-实践经验总结特定技巧解决问题"><a href="#四、技巧型设计模式-—-实践经验总结特定技巧解决问题" class="headerlink" title="四、技巧型设计模式 — 实践经验总结特定技巧解决问题"></a><span style="color:blue">四、技巧型设计模式</span> — 实践经验总结特定技巧解决问题</h2><h3 id="25、链模式（Chain-of-Responsibility-Pattern）"><a href="#25、链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="25、链模式（Chain of Responsibility Pattern）"></a>25、链模式（Chain of Responsibility Pattern）</h3><p><span style="color:red">链模式：</span>通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用（简化对该对象多次引用）。<br><br><span style="color:red">场景：</span>不想或不能明确指定请求的接收者时；有多个对象可以处理一个请求，且具体由哪个对象处理该请求在运行时动态决定时。<br><br><span style="color:red">优点：</span>增加了给对象指定职责的灵活性；且有新的处理者时不需要修改原有代码，符合开闭原则；降低对象之间的耦合度。<br><span style="color:red">缺点：</span>每个处理者都需要链中的请求进行判断，增加系统复杂性；不恰当使用会导致请求在链中传递时被忽视或未被处理。<br><br></p><h3 id="26、委托模式（Delegate-Pattern）"><a href="#26、委托模式（Delegate-Pattern）" class="headerlink" title="26、委托模式（Delegate Pattern）"></a>26、委托模式（Delegate Pattern）</h3><p><span style="color:red">委托模式：</span>有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象统一来处理请求。<br><br><span style="color:red">场景：</span>当一个对象需要将某个任务或请求委托给另一个对象处理时；需要实现事件处理或回调机制时。<br><br><span style="color:red">优点：</span>提高代码的复用性和灵活性，实现了任务或请求的委派，降低了类之间的耦合度。<br><span style="color:red">缺点：</span>委托链过长，可能会导致调用栈过深，影响性能；需要管理委托链的创建和维护，增加了代码的复杂性。<br><br></p><h3 id="27、数据访问对象模式（DAO-——-Data-Access-Object-Pattern）-数据管理器"><a href="#27、数据访问对象模式（DAO-——-Data-Access-Object-Pattern）-数据管理器" class="headerlink" title="27、数据访问对象模式（DAO —— Data Access Object Pattern）(数据管理器)"></a>27、数据访问对象模式（DAO —— Data Access Object Pattern）(数据管理器)</h3><p><span style="color:red">数据访问对象模式：</span>对数据源的访问与存储去抽象和封装，DAO通过数据源链接的管理方便对数据访问与存储。<br><br><span style="color:red">场景：</span>当需要将数据访问逻辑与业务逻辑分离，以提高代码的可读性和可维护性时；在需要实现数据的持久化存储，并且希望上层应用不依赖于具体数据库实现时。<br><br><span style="color:red">优点：</span>数据访问逻辑与业务逻辑分离，降低业务逻辑对数据库的直接依赖。<br><span style="color:red">缺点：</span>增加了代码量（需要为每个数据表或数据访问需求编写相应的DAO类）；数据库结构的变化可能需要修改多个DAO类。<br><br></p><h3 id="28、节流模式（Throttling-Pattern）"><a href="#28、节流模式（Throttling-Pattern）" class="headerlink" title="28、节流模式（Throttling Pattern）"></a>28、节流模式（Throttling Pattern）</h3><p><span style="color:red">节流模式：</span>对重复的业务逻辑进行节流，执行最后一次操作并取消其它操作。<br><br><span style="color:red">场景：</span>当系统资源有限需要防止资源被过度消耗时。当需要限制某个操作或请求的频率时，比如限制API的调用频率。<br><br><span style="color:red">优点：</span>减少不必要的操作或请求而提高系统性能；一定程度上防止资源耗尽或系统崩溃。<br><span style="color:red">缺点：</span>节流策略设置不当会导致关键操作被错误地节流；需要根据系统负载和资源情况动态调整节流策略。<br><br></p><h3 id="29、简单模板模式（Simple-Template-Pattern）"><a href="#29、简单模板模式（Simple-Template-Pattern）" class="headerlink" title="29、简单模板模式（Simple Template Pattern）"></a>29、简单模板模式（Simple Template Pattern）</h3><p><span style="color:red">简单模板模式：</span>描述了一种通过模板(或格式化)字符串来生成视图或文档的技巧，拼凑出视图避免创建视图时大量节点操作（优化内存开销）。<br><br><span style="color:red">场景：</span>需要根据模板生成大量相似但略有不同的视图或文档时；视图或文档的生成过程较为复杂且需要频繁更改模板时。<br><br><span style="color:red">优点：</span>提高视图或文档的生成效率，简化（视图或文档的生成）过程减少重复的代码。<br><span style="color:red">缺点：</span>模板字符串的维护可能变得复杂，特别是当模板结构复杂多变时；模板引擎的性能可能会影响最终的生成效率。<br><br></p><h3 id="30、惰性模式（Layier）"><a href="#30、惰性模式（Layier）" class="headerlink" title="30、惰性模式（Layier）"></a>30、惰性模式（Layier）</h3><p><span style="color:red">惰性模式：</span>减少（每次代码执行重复性的）分支判断，通过对对象重定义来屏蔽原对象中的分支判断。<br><br><span style="color:red">场景：</span>单页应用（SPA）中按需加载页面或组件。对象的创建或初始化开销较大，且不是每次都需要使用时。处理大量数据或复杂对象时，延迟加载非关键数据。<br><br><span style="color:red">优点：</span>延迟初始化对象的创建或资源的加载，减少不必要的计算和内存使用（性能优化）；需要时才初始化，特别是处理大量数据或复杂对象时（按需加载）；避免在程序启动时加载所有可能用不到的资源（简化代码）。<br><span style="color:red">缺点：</span>繁使用或需要频繁初始化，‌可能会导致运行时性能下降；大量数据或复杂计算时页面响应变慢，会影响到用户体验。<br><br></p><h3 id="31、参与者模式（Participator-Pattern）"><a href="#31、参与者模式（Participator-Pattern）" class="headerlink" title="31、参与者模式（Participator Pattern）"></a>31、参与者模式（Participator Pattern）</h3><p><span style="color:red">参与者模式：</span>特定作用域执行给的的函数，并将参数原封不动地传递。<br><br><span style="color:red">场景：</span>需要支持插件或扩展机制的应用。多个组件或对象可能共享状态，并通过某种机制（如Redux、Vuex等）来同步和管理这些状态（状态管理）。多个组件或对象通过事件共同监听和触发机制相互通信完成某项任务（事件监听与触发）。<br><br><span style="color:red">优点：</span>允许不同的组件或对象以灵活方式参与任务；参与者之间相对独立，降低系统间耦合度；易于添加新的参与者或修改现有参与者的行为。<br><span style="color:red">缺点：</span>参与者继续增加会增加系统的复杂性，且需要一种有效的机制来协调不同参与者之间的行为。<br><br></p><h3 id="32、等待者模式（Waiter-Pattern）"><a href="#32、等待者模式（Waiter-Pattern）" class="headerlink" title="32、等待者模式（Waiter Pattern）"></a>32、等待者模式（Waiter Pattern）</h3><p><span style="color:red">等待者模式：</span>通过监听多个异步操作，触发未来发生的动作。（通常指Promise或类似机制）<br><br><span style="color:red">场景：</span>处理网络请求、文件读写等异步操作。等待多个异步操作完成后才能继续执行后续逻辑的场景。处理异步操作结果并基于这些结果执行后续操作的场景。<br><br><span style="color:red">优点：</span>处理异步操作，避免回调地狱；支持链式调用方便处理多个异步操作的结果；统一的错误处理机制能集中处理可能的错误。<br><span style="color:red">缺点：</span>开发者需要熟悉Promise和异步编程；不恰当使用Promise（如创建过多的Promise链）会导致代码难理解和维护。<br></p><p><br><br></p><h2 id="五、架构型设计模式-—-提供些子系统并指定各职责再合体"><a href="#五、架构型设计模式-—-提供些子系统并指定各职责再合体" class="headerlink" title="五、架构型设计模式 — 提供些子系统并指定各职责再合体"></a><span style="color:blue"></span>五、架构型设计模式 — 提供些子系统并指定各职责再合体</h2><h3 id="33、同步模块模式（SDM-——-Synchronous-Module-Definition）"><a href="#33、同步模块模式（SDM-——-Synchronous-Module-Definition）" class="headerlink" title="33、同步模块模式（SDM —— Synchronous Module Definition）"></a>33、同步模块模式（SDM —— Synchronous Module Definition）</h3><p><span style="color:red">同步模块模式（模块化）：</span>发出请求后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。<br><br><span style="color:red">模块化：</span>将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率<br><br><span style="color:red">场景：</span>适用于任务顺序明确、逻辑简单的场景，如简单脚本、批处理任务。适用于CPU密集型任务和负载较低的小型应用。<br><br><span style="color:red">优点：</span>执行顺序与代码顺序一致易于理解和调试；错误处理简单，异常可以直接捕获和处理；资源管理方便，不需要考虑并发和上下文切换的问题。<br><span style="color:red">缺点：</span>低效的资源利用，特别是在等待I&#x2F;O操作（如网络请求、文件读写）完成时，CPU和其他资源可能处于闲置状态；阻塞问题，同步操作会阻塞主线程，可能导致应用程序的响应速度变慢，特别是在用户界面编程中，可能会导致界面卡顿。<br><br></p><h3 id="34、异步模块模式（AMD-——-Asynchronous-Module-Definition）"><a href="#34、异步模块模式（AMD-——-Asynchronous-Module-Definition）" class="headerlink" title="34、异步模块模式（AMD —— Asynchronous Module Definition）"></a>34、异步模块模式（AMD —— Asynchronous Module Definition）</h3><p><span style="color:red">异步模块模式（模块化）：</span>发出请求后，继续其他业务逻辑，直到模块加载完成执行后续的逻辑，实现模块开发中模块加载完成后的引用。<br><br><span style="color:red">模块化：</span>将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。<br><br><span style="color:red">场景：</span>适用于高并发、高吞吐量的场景，如Web服务器、网络编程等。适用于I&#x2F;O密集型任务和需要高并发处理的应用，如处理大量网络请求、文件I&#x2F;O操作等。<br><br><span style="color:red">优点：</span>提高系统吞吐量，在等待I&#x2F;O操作完成时可以继续执行其他任务；增强用户体验，特别是在用户界面编程中，可以避免界面卡顿，提高响应速度；资源利用率高，可以更高效地利用CPU和内存。<br><span style="color:red">缺点：</span>复杂性增加，异步编程通常比同步编程更复杂，需要处理回调、Promise、async&#x2F;await等；调试困难，异步操作的非线性执行顺序使得调试和追踪问题变得更加困难。<br><br></p><h3 id="35、组件化开发模式（Component-based-Development-Model）"><a href="#35、组件化开发模式（Component-based-Development-Model）" class="headerlink" title="35、组件化开发模式（Component-based Development Model）"></a>35、组件化开发模式（Component-based Development Model）</h3><p><span style="color:red">组件化开发模式：</span>将UI划分为一系列可复用的组件，每个组件都具有明确的功能和职责。<br><br><span style="color:red">场景：</span>适用于所有需要构建UI的前端应用，特别是当应用需要支持多种设备和屏幕尺寸时。<br><br><span style="color:red">优点：</span>提高代码的可维护性和可重用性，降低开发和维护成本。<br><span style="color:red">缺点：</span>需要合理的组件划分和架构设计，以避免组件间的过度耦合。<br><br></p><h3 id="36、Widget模式（小组件模式）"><a href="#36、Widget模式（小组件模式）" class="headerlink" title="36、Widget模式（小组件模式）"></a>36、Widget模式（小组件模式）</h3><p><span style="color:red">Widget模式：</span>强调组件的独立性和可重用性，借用Web Widget思想将页面分解成部件（组件），针对部件开发，最终组合成完整的页面。<br><br><span style="color:red">场景：</span>Web开发，特别是需要快速迭代和部署的项目。适用于需要高度自定义和可配置用户界面的应用，如企业级应用、电商平台等。<br><br><span style="color:red">优点：</span>封装复杂的UI细节和操作可更轻松创建用户界面；内置的丰富交互效果（如动画、响应式设计）给用户更多操作体验；组件化开发减少重复代码需求，降低后期修改、优化和调试的时间成本。<br><span style="color:red">缺点：</span>组件间接口不合理会增加系统复杂性；组件都要额外的渲染和状态管理，过度细化导致系统的整体性能下降。<br><br></p><h3 id="37、前端路由模式（Front-end-Routing-Pattern）"><a href="#37、前端路由模式（Front-end-Routing-Pattern）" class="headerlink" title="37、前端路由模式（Front-end Routing Pattern）"></a>37、前端路由模式（Front-end Routing Pattern）</h3><p><span style="color:red">前端路由模式：</span>一种在用户界面中实现页面跳转的技术，它不需要重新加载页面，而是通过JavaScript动态地改变URL并更新页面内容。<br><br><span style="color:red">场景：</span>适用于SPA（单页应用）和需要实现无刷新页面跳转的前端应用。<br><br><span style="color:red">优点：</span>提高用户体验，使得页面跳转更加流畅和自然。<br><span style="color:red">缺点：</span>需要额外的开发和配置工作，以确保路由的正确性和可用性。<br><br></p><!-- #### 38、Flux/Redux模式（响应式模式也是框架，及其它vue）Flux/Redux模式：Flux和Redux是两种状态管理架构（Redux是进化Flux），它们通过中心化的状态管理来避免复杂的组件间通信，使得应用的状态变化更加可预测和易于管理。<br>场景：适用于大型、复杂的前端应用，特别是当应用的状态管理变得复杂且难以控制时。<br>优缺点：提高应用的可维护性和可扩展性，使状态变化更加清晰和可追踪。。对初学者掌握就比较复杂。 --><h3 id="38、响应式设计模式（Responsive-Design-Pattern）"><a href="#38、响应式设计模式（Responsive-Design-Pattern）" class="headerlink" title="38、响应式设计模式（Responsive Design Pattern）"></a>38、响应式设计模式（Responsive Design Pattern）</h3><p><span style="color:red">响应式设计模式：</span>一种使网页能够在不同设备和屏幕尺寸上良好展示的设计方法。<br><br><span style="color:red">场景：</span>适用于所有需要支持移动设备访问的网页和前端应用。如Flux&#x2F;Redux设计模式（Redux是进化Flux）、Dva、VUEX等状态管理框架。<br><br><span style="color:red">优点：</span>提高用户体验，使网页能在不同设备切换。<br><span style="color:red">缺点：</span>可能需要额外的开发和测试工作，以确保网页在不同设备和屏幕尺寸上的兼容性。<br><br></p><h3 id="39、MVC模式（Model-View-Controller）"><a href="#39、MVC模式（Model-View-Controller）" class="headerlink" title="39、MVC模式（Model-View-Controller）"></a>39、MVC模式（Model-View-Controller）</h3><p><span style="color:red">MVC模式：</span>一种将应用程序分为三个主要部分的架构模式：模型（Model）、视图（View）和控制器（Controller）。模型负责业务逻辑和数据管理，视图负责展示数据，控制器负责接收用户输入并调用模型和视图以完成用户请求。<br><br><span style="color:red">场景：</span>适用于需要明确分离业务逻辑、数据展示和用户交互的复杂前端应用，如企业级应用、电商平台等。<br><br><span style="color:red">优点：</span>降低代码耦合度提高可维护性，使开发团队可更加专注各自部分。<br><span style="color:red">缺点：</span>在某些情况下可能导致代码的重复和复杂性增加，特别是在视图和控制器之间的交互较多时。<br><br></p><h3 id="40、MVP模式（Model-View-Presenter）"><a href="#40、MVP模式（Model-View-Presenter）" class="headerlink" title="40、MVP模式（Model-View-Presenter）"></a>40、MVP模式（Model-View-Presenter）</h3><p><span style="color:red">MVP模式：</span>是MVC模式的一个变体，旨在更好地分离视图（View）和模型（Model）并引入一个介于它们之间主持人——呈现器（Presenter）。<br><br><span style="color:red">场景：</span>特别适用于需要清晰分离用户界面逻辑和业务逻辑的场景，比如大型Android或iOS应用。<br><br><span style="color:red">优点：</span>业务逻辑从表示层分离出来，提高代码的可维护性和可测试性；测试方便（Presenter独立于View，可直接测试Presenter逻辑而不需运行UI代码）；Model与View分离使Model可被多个View复用；各个组件间依赖关系较低，降低系统的耦合度；与直接使用MVC或MVVM（Model-View-ViewModel）等模式相比，MVP引入了Presenter这一额外的层，增加了系统的复杂性。<br><span style="color:red">缺点：</span>对于初学者来说，理解和实现MVP模式可能比MVC模式更加困难。<br><br></p><h3 id="41、MVVM模式（Model-View-ViewModel）"><a href="#41、MVVM模式（Model-View-ViewModel）" class="headerlink" title="41、MVVM模式（Model-View-ViewModel）"></a>41、MVVM模式（Model-View-ViewModel）</h3><p><span style="color:red">MVVM模式：</span>（MVC基础上演化）引入了一个视图模型（ViewModel）作为桥梁，负责处理视图和模型之间的数据绑定。<br><br><span style="color:red">场景：</span>适用于需要实现双向数据绑定和复杂交互的前端应用，如SPA（单页应用）、数据可视化工具等。<br><br><span style="color:red">优点：</span>简化代码维护，更好可测试性，通过数据绑定减少代码量。<br><span style="color:red">缺点：</span>响应式系统可能变得复杂且难以理解，特别是在处理大量数据和复杂交互时。<br><br></p><!-- ## 常用的哪些模式？其实并非有固定的常用模式，哪些适合你的开发，哪些经常使用就是常用模式（废话多了...），一句话，要使用的就是常用的模式下面列举一些：1、外观模式2、代理模式 3、工厂模式 4、单例模式5、策略模式6、观察者模式7、中介者模式8、访问者模式9、装饰者模式10、迭代器模式11、模块模式12、构造函数模式13、混合模式 --><p><br><br><br><br><br>（待续…）<br><br><br></p><p style="font-size: 8px">  部分资源转载于：《JavaScript设计模式》一书<br></p><br><p style="font-size: 10px">注：<br>本站商业转载需<a href="https://email.163.com/">联系博主:wyyx9082hgl@163.com</a>授权，非商业转载请注明出处。<br>    无法联系博主请在评论区注明，未经授权或无联系方式相关法律责任问题将追究。</p><p style="font-size: 10px">    本站为学习交流使用，非商业用途。如有资源侵权请<a href="https://email.163.com/">[联系博主]</a>，感谢您的支持！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前后端</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录与分享：学习网站</title>
    <link href="/tomnyblog.github.io/2024/05/01/frontend-html/"/>
    <url>/tomnyblog.github.io/2024/05/01/frontend-html/</url>
    
    <content type="html"><![CDATA[<h2 id="分享些倾向编程开发知识学习网站。学海无涯-撸！！"><a href="#分享些倾向编程开发知识学习网站。学海无涯-撸！！" class="headerlink" title="分享些倾向编程开发知识学习网站。学海无涯~~~撸！！"></a>分享些倾向编程开发知识学习网站。学海无涯~~~撸！！</h2><span id="more"></span>  <!-- 这行more存在的意义是使more下面内容不显示在主页 --><span style="font-size: 10px;">    本站资源仅供学习交流，非商业用途，如有资源侵权请<a href="https://email.163.com/" style="color: red;">联系博主：wyyx9082hgl@163.com</a>；<br>网站若失效或无法联系博主请在评论区注明，感谢您的支持。</span><h3 id="1、编程开发综合技术网"><a href="#1、编程开发综合技术网" class="headerlink" title="1、编程开发综合技术网"></a>1、编程开发综合技术网</h3><p>W3school   <a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a><br>菜鸟教程   <a href="https://www.cainiaojc.com/">https://www.cainiaojc.com/</a><br>网道教程   <a href="https://wangdoc.com/">https://wangdoc.com/</a><br>MDN(mozilla)官网   <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a><br>MDN(mozilla)Web开发中文网   <a href="https://developer.mozilla.org/zh-CN/docs/Web">https://developer.mozilla.org/zh-CN/docs/Web</a><br>JavaScrip中文网   <a href="https://www.javascriptcn.com/">https://www.javascriptcn.com/</a><br>C语言网   <a href="https://www.dotcpp.com/">https://www.dotcpp.com/</a><br>C语言中文网   <a href="https://c.biancheng.net/index.html">https://c.biancheng.net/index.html</a><br>慕课网   <a href="https://www.imooc.com/">https://www.imooc.com/</a><br>51HTML5技术网   <a href="https://www.51html5.com/">https://www.51html5.com/</a><br>w3s的HTML5教程与手册   <a href="http://www.w3school.com.cn/html5/html5_reference.asp">http://www.w3school.com.cn/html5/html5_reference.asp</a><br>Python中文网   <a href="https://python.p2hp.com/">https://python.p2hp.com/</a><br>Boss设计   <a href="https://www.bossdesign.cn/">https://www.bossdesign.cn/</a><br>5axxw(我爱学习网)  <a href="https://www.5axxw.com/">https://www.5axxw.com/</a><br>（综合42个非常有用的资源网）  <a href="https://www.yixieshi.com/W">https://www.yixieshi.com/W</a></p><h3 id="2、编程开发的相关论坛网"><a href="#2、编程开发的相关论坛网" class="headerlink" title="2、编程开发的相关论坛网"></a>2、编程开发的相关论坛网</h3><p>知乎   <a href="https://www.zhihu.com/">https://www.zhihu.com/</a><br>CSDN社区   <a href="https://www.csdn.net/">https://www.csdn.net/</a><br>稀土掘金   <a href="https://juejin.cn/">https://juejin.cn/</a><br>SegmentFault(思否)社区   <a href="https://segmentfault.com/">https://segmentfault.com/</a><br>微信开放社区   <a href="https://developers.weixin.qq.com/community/homepage">https://developers.weixin.qq.com/community/homepage</a><br>Oschina开源社区   <a href="https://www.oschina.net/">https://www.oschina.net/</a><br>open-open深度开源社区   <a href="https://www.open-open.com/">https://www.open-open.com/</a><br>learnku论坛   <a href="https://learnku.com/">https://learnku.com/</a><br>51CTO博客网   <a href="https://blog.51cto.com/">https://blog.51cto.com/</a><br>php中文网   <a href="https://www.php.cn/">https://www.php.cn/</a><br>术之多   <a href="https://www.shuzhiduo.com/">https://www.shuzhiduo.com/</a><br>前端2024新技术   <a href="https://sg-info.cn/article/show/44981">https://sg-info.cn/article/show/44981</a></p><p>博客-框架&#x2F;系统：<br>hexo（静态博客框架）  <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br>Solo（基于Java动态博客系统）  <a href="https://soloist.ai/">https://soloist.ai/</a><br>Hugo（基于Go静态网站生成器） 官网：<a href="https://gohugo.io/">https://gohugo.io/</a>   中文网：<a href="https://www.gohugo.org/">https://www.gohugo.org/</a><br>jekyll（基于Ruby静态网站生成器平台）  <a href="https://www.jekyll.com.cn/">https://www.jekyll.com.cn/</a><br>typecho（基于php博客平台）  <a href="https://typecho.org/">https://typecho.org/</a><br>WordPress（基于php博客系统平台）   <a href="https://wordpress.com/zh-cn/create-blog/">https://wordpress.com/zh-cn/create-blog/</a><br>Halo（静态博客框架系统）  <a href="https://www.halo.run/archives">https://www.halo.run/archives</a></p><!-- ### 3、HTML(5) --><!-- 开源oschina的HTML与HTML5是啥？ http://www.oschina.net/news/24400/what-is-html5  (2011-12-28) 开源oschina的HTML5的弊端 http://www.oschina.net/news/23965/5-things-that-html5-lacks  (2011-12-28) 15个HTML游戏 http://www.oschina.net/news/18139/15-best-html5-games-of-2011 --><!-- 51网HTML http://developer.51cto.com/art/201101/243211.htm （网站被黑有色链） --><h3 id="3、Javascript"><a href="#3、Javascript" class="headerlink" title="3、Javascript"></a>3、Javascript</h3><p>MDN-javascript官网   <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a><br>ECMAScript标准   <a href="https://ecma-international.org/publications-and-standards/standards/ecma-262/">https://ecma-international.org/publications-and-standards/standards/ecma-262/</a><br>Node.js（Chrome V8运行时环境）   <a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a><br>ES6(阮一峰)   <a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a><br>网道ES6教程   <a href="https://wangdoc.com/es6">https://wangdoc.com/es6</a><br>网道TypeScript教程   <a href="https://wangdoc.com/typescript//">https://wangdoc.com/typescript//</a><br>typescript中文网   <a href="https://www.tslang.cn/">https://www.tslang.cn/</a><br>jQuery api中文网   <a href="https://www.jquery123.com/">https://www.jquery123.com/</a><br>axios中文网   <a href="https://www.axios-http.cn/">https://www.axios-http.cn/</a><br>JSON中国-中文网   <a href="https://www.json.org.cn/">https://www.json.org.cn/</a><br>W3C网JSON教程   <a href="https://www.w3cschool.cn/json/">https://www.w3cschool.cn/json/</a><br>google解析json工具GSON博客   <a href="https://www.iteye.com/blog/jackyrong-848353">https://www.iteye.com/blog/jackyrong-848353</a></p><p>（函数式编程&#x2F;工具库：）<br>函数范式(functional paradigm)   <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/</a><br>Lodash库   <a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a><br>Radash库(被称新一代’Lodash’，网站可能需要梯子)   <a href="https://radash-docs.vercel.app/docs/getting-started">https://radash-docs.vercel.app/docs/getting-started</a><br>Ramda库(中文)   <a href="https://ramda.cn/">https://ramda.cn/</a><br>RxJS库(ReactiveX-响应式异步编程)   <a href="https://rxjs.dev/">https://rxjs.dev/</a>   （中文网：）<a href="https://cn.rx.js.org/">https://cn.rx.js.org/</a></p><p>（前端构建工具：）<br>webpack(基于node.js)   <a href="https://webpack.docschina.org/">https://webpack.docschina.org/</a><br>parcel(基于Rust)   <a href="https://parceljs.org/">https://parceljs.org/</a>   (中文网:）<a href="https://parcel.nodejs.cn/">https://parcel.nodejs.cn/</a><br>viet(基于原生ES模块)   <a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a><br>Browserify(基于node.js)  <a href="http://browserify.org/">http://browserify.org/</a> （需梯子）<br>esbuild(基于Go)   <a href="https://esbuild.github.io/">https://esbuild.github.io/</a>    (中文网:）<a href="https://www.esbuild.cn/">https://www.esbuild.cn/</a><br>grunt(基于node.js)  <a href="https://gruntjs.com/">https://gruntjs.com/</a>    (中文网:）<a href="https://www.gruntjs.net/">https://www.gruntjs.net/</a><br>gulp(基于node.js)   <a href="https://gulpjs.com/">https://gulpjs.com/</a>   (中文网:）<a href="https://www.gulpjs.com.cn/">https://www.gulpjs.com.cn/</a></p><h3 id="4、VUE"><a href="#4、VUE" class="headerlink" title="4、VUE"></a>4、VUE</h3><p>vue官网   <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a><br>vue3中文网   <a href="https://www.javascriptc.com/vue3js/">https://www.javascriptc.com/vue3js/</a><br>vue3社区网   <a href="https://www.vue3js.cn/">https://www.vue3js.cn/</a><br>vue3-Api参考   <a href="https://www.javascriptc.com/vue3js/api/">https://www.javascriptc.com/vue3js/api/</a><br>vue3-ajax-axios(菜鸟教程)   <a href="https://www.runoob.com/vue3/vue3-ajax-axios.html">https://www.runoob.com/vue3/vue3-ajax-axios.html</a><br>vuex-class(类组件绑定助手)   <a href="https://github.com/ktsn/vuex-class">https://github.com/ktsn/vuex-class</a></p><p>（生态：）<br>vue-Cli(工程化)脚手架   <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a><br>vue-Router路由   <a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a>  (v3-router) <a href="https://v3.router.vuejs.org/zh/">https://v3.router.vuejs.org/zh/</a><br>VueX状态管理模式   <a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a>  (vueX3) <a href="https://v3.vuex.vuejs.org/zh/">https://v3.vuex.vuejs.org/zh/</a><br>vue-devtools调试工具   <a href="https://github.com/vuejs/devtools">https://github.com/vuejs/devtools</a></p><h3 id="5、UI框架"><a href="#5、UI框架" class="headerlink" title="5、UI框架"></a>5、UI框架</h3><p>Bootstrap中文网   <a href="https://www.bootcss.com/">https://www.bootcss.com/</a><br>jQuery-UI   <a href="https://jqueryui.com/">https://jqueryui.com/</a><br>Element官网(基于vue2-饿了么)   <a href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a><br>Element官网(基于vue3-饿了么)  <a href="https://element-plus.org/zh-CN/#/zh-CN">https://element-plus.org/zh-CN/#/zh-CN</a><br>iview官网(基于vue)   <a href="https://iview.github.io/%EF%BC%88%E6%97%A7%E7%89%88%EF%BC%89">https://iview.github.io/（旧版）</a><br>(iview)View Design官网(基于vue3)  <a href="https://www.iviewui.com/">https://www.iviewui.com/</a><br>Mint官网(基于vue2-移动端)   <a href="https://mint-ui.github.io/#!/zh-cn">https://mint-ui.github.io/#!/zh-cn</a><br>vux官网(基于vue-移动端)   <a href="https://vux.li/">https://vux.li/</a><br>Ant Design官网(基于React&#x2F;React Native)   <a href="https://ant.design/index-cn">https://ant.design/index-cn</a><br>Ant Design Mobile官网(基于React&#x2F;RN-移动端)  <a href="https://mobile.ant.design/zh">https://mobile.ant.design/zh</a><br>UI-weui(微信小程序)   <a href="https://wechat.design/tool/weui-mobile/">https://wechat.design/tool/weui-mobile/</a><br>Electron（桌面应用框架）  <a href="https://www.electronjs.org/zh/">https://www.electronjs.org/zh/</a></p><p>（可视化图表库：）<br>Echart柱状图扇形图   <a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a><br>Isqqw Echart demo集   <a href="https://www.isqqw.com/">https://www.isqqw.com/</a><br>Hcharts折线图曲线图   <a href="https://www.hcharts.cn/">https://www.hcharts.cn/</a><br>FormMaking低代码表单设计器   <a href="https://form.making.link/docs/">https://form.making.link/docs/</a></p><h3 id="6、第三方接口api"><a href="#6、第三方接口api" class="headerlink" title="6、第三方接口api"></a>6、第三方接口api</h3><p>支付宝开发平台   <a href="https://opendocs.alipay.com/common">https://opendocs.alipay.com/common</a><br>QQ开放平台   <a href="https://q.qq.com/#/">https://q.qq.com/#/</a><br>腾讯Ai开放平台   <a href="https://ai.qq.com/">https://ai.qq.com/</a><br>腾讯应用开发平台   <a href="https://app.open.qq.com/p/home">https://app.open.qq.com/p/home</a><br>微信开放平台   <a href="https://open.weixin.qq.com/">https://open.weixin.qq.com/</a><br>微信支付   <a href="https://pay.weixin.qq.com/wiki/doc/api/index.html">https://pay.weixin.qq.com/wiki/doc/api/index.html</a><br>Github API(apifox)   <a href="https://github.apifox.cn/">https://github.apifox.cn/</a><br>微博开放平台   <a href="https://open.weibo.com/">https://open.weibo.com/</a><br>高德地图开放平台   <a href="https://lbs.amap.com/">https://lbs.amap.com/</a><br>Chrome Map   <a href="https://developers.google.cn/maps/documentation/api-picker?hl=zh-cn">https://developers.google.cn/maps/documentation/api-picker?hl=zh-cn</a><br>OpenWeatherMap(免费天气)   <a href="https://openweathermap.org/">https://openweathermap.org/</a><br>今日诗词   <a href="https://www.jinrishici.com/">https://www.jinrishici.com/</a><br>hitokoto(一言随机语录)   <a href="https://v1.hitokoto.cn/">https://v1.hitokoto.cn/</a></p><h3 id="7、一些好玩的插件和组件"><a href="#7、一些好玩的插件和组件" class="headerlink" title="7、一些好玩的插件和组件"></a>7、一些好玩的插件和组件</h3><p>typed.js打字机   <a href="https://mattboldt.github.io/typed.js/">https://mattboldt.github.io/typed.js/</a><br>Three.js(可视化3D库)   <a href="https://threejs.org/">https://threejs.org/</a>    (中文文档:) <a href="https://threejs.org/docs/index.html#manual/zh/">https://threejs.org/docs/index.html#manual/zh/</a><br>swiper轮播图   <a href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a><br>Lottie(动画插件Android)   <a href="https://github.com/airbnb/lottie-android">https://github.com/airbnb/lottie-android</a><br>Curve.js(动画文字线条)  <a href="https://alloyteam.github.io/curvejs/">https://alloyteam.github.io/curvejs/</a><br>Moment.js(时间日期库)   <a href="https://momentjs.cn/">https://momentjs.cn/</a><br>Day.js(时间日期库)   <a href="https://day.js.org/zh-CN/">https://day.js.org/zh-CN/</a><br>Anime.js(动画库)   <a href="https://animejs.com/">https://animejs.com/</a><br>velocity(动画库)   <a href="http://velocityjs.org/">http://velocityjs.org/</a>  （js库github:) <a href="https://github.com/shepherdwind/velocity.js">https://github.com/shepherdwind/velocity.js</a><br>lottie(解析json动画库)   <a href="https://airbnb.io/lottie/#/">https://airbnb.io/lottie/#/</a><br>Rough Notation(网页类手绘动画库)   <a href="https://roughnotation.com/">https://roughnotation.com/</a>  (github文档:) <a href="https://github.com/rough-stuff/rough-notation">https://github.com/rough-stuff/rough-notation</a><br>Popmotion(动画库)   <a href="https://popmotion.io/">https://popmotion.io/</a><br>Vivus(SVG动画库)   <a href="https://maxwellito.github.io/vivus/">https://maxwellito.github.io/vivus/</a><br>平台-jsfiddle(在线写代码)   <a href="https://jsfiddle.net/">https://jsfiddle.net/</a></p><h3 id="8、CSS-3-和扩展的预处理"><a href="#8、CSS-3-和扩展的预处理" class="headerlink" title="8、CSS(3)和扩展的预处理"></a>8、CSS(3)和扩展的预处理</h3><p>w3s的CSS   <a href="https://www.w3cschool.cn/css/">https://www.w3cschool.cn/css/</a><br>w3s的syulus   <a href="https://www.w3cschool.cn/stylus_china/">https://www.w3cschool.cn/stylus_china/</a><br>less官网中文   <a href="https://less.bootcss.com/">https://less.bootcss.com/</a><br>sass官网中文   <a href="https://www.sass.hk/">https://www.sass.hk/</a></p><h3 id="9、浏览器监听网（运维与监控）"><a href="#9、浏览器监听网（运维与监控）" class="headerlink" title="9、浏览器监听网（运维与监控）"></a>9、浏览器监听网（运维与监控）</h3><p>HTML浏览器监听网站   <a href="http://html5test.com/">http://html5test.com/</a><br>定位js异常监控方案   <a href="https://foio.github.io/babel-try-catch/">https://foio.github.io/babel-try-catch/</a><br>Zabbix(分布式系统监控与网络监控)  <a href="https://www.zabbix.com/">https://www.zabbix.com/</a><br>Nagios(企业级监控)   <a href="https://www.nagios.org/">https://www.nagios.org/</a><br>Ganglia(集群监控)   <a href="http://ganglia.info/">http://ganglia.info/</a><br>监控宝(IT性能监控)   <a href="https://www.jiankongbao.com/">https://www.jiankongbao.com/</a><br>听云(应用性能监控)   <a href="http://www.tingyun.com/">http://www.tingyun.com</a></p><p><br><br><br><br><br>（待续…）<br><br><br></p><p>不定时更新…您应该知道还有很多网站的，评论区走一个？</p><p><br><br><br></p><p style="font-size: 10px">    本站商业转载需<a href="https://email.163.com/">联系博主:wyyx9082hgl@163.com</a>授权，非商业转载请注明出处。<br>    无法联系博主请在评论区注明，未经授权或无联系方式相关法律责任问题将追究。</p>]]></content>
    
    
    <categories>
      
      <category>前后端网站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前后端</tag>
      
      <tag>网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线多款网页版小游戏</title>
    <link href="/tomnyblog.github.io/2024/04/28/webGamingPage/"/>
    <url>/tomnyblog.github.io/2024/04/28/webGamingPage/</url>
    
    <content type="html"><![CDATA[<h2 id="基于HTML5开发的网页版休闲益智小游戏"><a href="#基于HTML5开发的网页版休闲益智小游戏" class="headerlink" title="基于HTML5开发的网页版休闲益智小游戏~~"></a>基于HTML5开发的网页版休闲益智小游戏~~</h2><span id="more"></span>  <!-- 这行more：是使more下面内容不显示在主页 --><span style="font-size: 10px;">    本站资源仅供学习交流，非商业用途，如有资源侵权请<a href="https://email.163.com/" style="color: red;">联系博主：wyyx9082hgl@163.com</a>；<br>网站若失效或无法联系博主请在评论区注明，感谢您的支持。</span><h3 id="1、游戏：环面方块-Torus-3D"><a href="#1、游戏：环面方块-Torus-3D" class="headerlink" title="1、游戏：环面方块(Torus-3D)"></a>1、游戏：<a href="https://www.benjoffe.com/code/games/torus/">环面方块(Torus-3D)</a></h3><p>这是一款简约益智类似俄罗斯方块的的环面方块小游戏，玩法：界面内点击‘Play’即可开始，点击上方向键变换方块，点击左右移动位置，点击下方向键加速向下；界面内点击‘Settings’可选择不同底座（共两个），也可查看分数~~~<br><img src="/tomnyblog.github.io/images/games/gameTorus.png" alt="环面方块(Torus-3D) images"> </p><h3 id="2、游戏：导向游戏-Missile-Game"><a href="#2、游戏：导向游戏-Missile-Game" class="headerlink" title="2、游戏：导向游戏(Missile Game)"></a>2、游戏：<a href="https://missile-game.bwhmather.com/">导向游戏(Missile Game)</a></h3><p>这是一款简约第一人称重力感跨障碍物小游戏，玩法：鼠标单击界面开始游戏，以鼠标移动为方向，穿越障碍物~~~<br><img src="/tomnyblog.github.io/images/games/gameMissileGame.png" alt="导向游戏(Missile Game) images"> </p><h3 id="3、游戏：连锁反应-Chain-Reaction"><a href="#3、游戏：连锁反应-Chain-Reaction" class="headerlink" title="3、游戏：连锁反应(Chain Reaction)"></a>3、游戏：<a href="https://www.yvoschaap.com/chainrxn/">连锁反应(Chain Reaction)</a></h3><p>这是一款简约益智的小游戏，玩法：在游戏界面内随机点击一处位置生成大球，自动随机移动的小球碰到会立刻同化，小球数目达到要求连锁反应才能过关~~~<br><img src="/tomnyblog.github.io/images/games/gameChainReaction.png" alt="连锁反应(Chain Reaction) images"> </p><h3 id="4、游戏：连锁反应-加强版-Chain-Reaction-Advanced"><a href="#4、游戏：连锁反应-加强版-Chain-Reaction-Advanced" class="headerlink" title="4、游戏：连锁反应:加强版(Chain Reaction:Advanced)"></a>4、游戏：<a href="https://yvoschaap.com/chainrxnadvanced/">连锁反应:加强版(Chain Reaction:Advanced)</a></h3><p>这是一款连锁反应(Chain Reaction)的加强版小游戏，大球小球不一样同化变化，速度也有变化，开始选择的大球更加慎重~~~<br><img src="/tomnyblog.github.io/images/games/gameChainReactionAdvanced.png" alt="连锁反应:加强版(Chain Reaction:Advanced) images"></p><h3 id="5、游戏：数字连连看-play-dot-to"><a href="#5、游戏：数字连连看-play-dot-to" class="headerlink" title="5、游戏：数字连连看(play-dot-to)"></a>5、游戏：<a href="https://play-dot-to.com/">数字连连看(play-dot-to)</a></h3><p>这是一款简约益智的小游戏，玩法：按顺序点击数字连接，注意最后一个连回‘1’哦，还有时间限制哦~~~<br><img src="/tomnyblog.github.io/images/games/gamePlaydotto.png" alt="数字连连看(play-dot-to) images"><br><img src="/tomnyblog.github.io/images/games/gamePlaydotto2.png" alt="数字连连看(play-dot-to) images"> </p><h3 id="6、游戏：连一连-Connection"><a href="#6、游戏：连一连-Connection" class="headerlink" title="6、游戏：连一连(Connection)"></a>6、游戏：<a href="https://connection.ivank.net/">连一连(Connection)</a></h3><p>这是一款简约小图像连一连的小游戏，玩法：选择相同的小图像点击空格生成线，需要去除线再点一下，注意有时间限制哦~~~<br><img src="/tomnyblog.github.io/images/games/gameConnection.png" alt="连一连(Connection) images"><br><img src="/tomnyblog.github.io/images/games/gameConnection2.png" alt="连一连(Connection) images"> </p><h3 id="7、游戏：生物实验室灾难-Biolab-Disaster"><a href="#7、游戏：生物实验室灾难-Biolab-Disaster" class="headerlink" title="7、游戏：生物实验室灾难(Biolab Disaster)"></a>7、游戏：<a href="https://playbiolab.com/">生物实验室灾难(Biolab Disaster)</a></h3><p>这是一款射击类的小游戏，玩法：点击键盘‘H’键或‘C’键开始，按‘X’键为跳跃，按‘C’键为射击，左右方向键换向，闯关途中有自动存档的功能~~~<br><img src="/tomnyblog.github.io/images/games/gameBiolabDisaster.png" alt="生物实验室灾难(Biolab Disaster) images"><br><img src="/tomnyblog.github.io/images/games/gameBiolabDisaster2.png" alt="生物实验室灾难(Biolab Disaster) images"> </p><h3 id="8、游戏：黑暗时代-Dark-Age"><a href="#8、游戏：黑暗时代-Dark-Age" class="headerlink" title="8、游戏：黑暗时代(Dark Age)"></a>8、游戏：<a href="https://www.def-logic.com/_dhtml/darkage/index.html">黑暗时代(Dark Age)</a></h3><p>这是一款射击类闯关的小游戏，玩法：点击键盘‘Z’键开始，进入后按方向键或‘W’‘S’‘A’‘D’键对应上下左右方向，按‘Z’键射击，消灭黑暗怪物冲到指定出口~~~<br><img src="/tomnyblog.github.io/images/games/gameDarkAge.png" alt="黑暗时代(Dark Age) images"><br><img src="/tomnyblog.github.io/images/games/gameDarkAge2.png" alt="黑暗时代(Dark Age) images"> </p><h3 id="9、游戏：魔术师-Magician"><a href="#9、游戏：魔术师-Magician" class="headerlink" title="9、游戏：魔术师(Magician)"></a>9、游戏：<a href="http://www.relfind.com/game/magician.html">魔术师(Magician)</a></h3><p>这是一款扔小火把救出精灵小仙女的射击类小游戏，玩法：界面使用鼠标点击‘START GAME’开始，进入游戏点击鼠标扔火把，鼠标移动带动方向，精灵小仙女左右侧随机出现，到达右左侧时没有救出则减少血条，当为0时游戏失败~~~<br><img src="/tomnyblog.github.io/images/games/gameMagician.png" alt="魔术师(Magician) images"><br><img src="/tomnyblog.github.io/images/games/gameMagician2.png" alt="魔术师(Magician) images"> </p><h3 id="10、游戏：波比排球2-Blobby-Volley2"><a href="#10、游戏：波比排球2-Blobby-Volley2" class="headerlink" title="10、游戏：波比排球2(Blobby Volley2)"></a>10、游戏：<a href="http://blobbyvolley.de/data/bv2browser/index.html">波比排球2(Blobby Volley2)</a></h3><p>这是一款可个人或双人的顶球类似排球的益智游戏，玩法：主界面可选VS人机或双人操作，点击键盘‘enter’开始，进入后左侧任务按‘A’和‘D’移动、‘W’跳跃顶球，右侧人物按‘H’和‘K’移动、‘U’跳跃顶球，一方落地判为输。点击右下角‘close’可暂停~~~<br><img src="/tomnyblog.github.io/images/games/gameBlobbyVolley2.png" alt="波比排球2(Blobby Volley2) images"> </p><h3 id="11、游戏：沙坑-Sand-Trap"><a href="#11、游戏：沙坑-Sand-Trap" class="headerlink" title="11、游戏：沙坑(Sand Trap)"></a>11、游戏：<a href="https://gopherwoodstudios.com/sandtrap/sand-trap.htm">沙坑(Sand Trap)</a></h3><p>这是一款重力类益智小游戏，玩法：点击‘let’s Play’开始，点击键盘右键顺时针旋转，点击键盘左键逆时针旋转，或者鼠标点击对角按住拖动。沙子倒入中间的桶达标后下一关，沙子掉入沙滩达到左下角标注时即失败，需要点击‘Try Again?’或‘Reset’键重新开始，点击‘Leave’可选择关卡~~~<br><img src="/tomnyblog.github.io/images/games/gameSandTrap.png" alt="沙坑(Sand Trap) images"> </p><h3 id="12、游戏：六角拼图-Entanglement-（网页初始加载会慢一些）"><a href="#12、游戏：六角拼图-Entanglement-（网页初始加载会慢一些）" class="headerlink" title="12、游戏：六角拼图(Entanglement)（网页初始加载会慢一些）"></a>12、游戏：<a href="http://entanglement.gopherwoodstudios.com/zh-CN-index.html">六角拼图(Entanglement)</a>（网页初始加载会慢一些）</h3><p>这是一款益智类休闲游戏，玩法：选择单人或多人游戏，进入后选择模式（多模式选择需要登陆），按上或左方向键逆时针旋转，按下或右方向键顺时针旋转，‘enter’键或空格键为确认；或者使用鼠标转轮旋转，点击为确认；当线路不通可点击左下角方块切换，最外环或最内连线即完成拼图~~~<br><img src="/tomnyblog.github.io/images/games/gameEntanglement.png" alt="六角拼图(Entanglement) images"><br><img src="/tomnyblog.github.io/images/games/gameEntanglement2.png" alt="六角拼图(Entanglement) images"> </p><h3 id="13、游戏：动物拼图-Animals-Puzzle"><a href="#13、游戏：动物拼图-Animals-Puzzle" class="headerlink" title="13、游戏：动物拼图(Animals Puzzle)"></a>13、游戏：<a href="https://gems.bushidoit.com/example1.php">动物拼图(Animals Puzzle)</a></h3><p>这是一款类似消消除的益智小游戏，玩法：点击动物进入界面，点击某个图案与旁边切换(去除有链条的图案)，达到分数后进入下一个动物世界，将动物拼图闯关~~~<br><img src="/tomnyblog.github.io/images/games/gameAnimalsPuzzle.png" alt="动物拼图(Animals Puzzle) images"><br><img src="/tomnyblog.github.io/images/games/gameAnimalsPuzzle2.png" alt="动物拼图(Animals Puzzle) images"> </p><h3 id="14、游戏：Construct在线游戏集合"><a href="#14、游戏：Construct在线游戏集合" class="headerlink" title="14、游戏：Construct在线游戏集合"></a>14、游戏：<a href="https://www.construct.net/en/free-online-games">Construct在线游戏集合</a></h3><p>这是一个国外经典游戏集合的游戏引擎网站，作为浏览器游戏开发的引擎，内部多款游戏可玩~~~<br><img src="/tomnyblog.github.io/images/games/gameConstruct.png" alt="Construct在线游戏集合 images"><br><img src="/tomnyblog.github.io/images/games/gameConstruct2.png" alt="Construct在线游戏集合 images"> </p><h3 id="15、游戏：宝玩-poki-在线游戏集合—sky-mad"><a href="#15、游戏：宝玩-poki-在线游戏集合—sky-mad" class="headerlink" title="15、游戏：宝玩(poki)在线游戏集合—sky-mad"></a>15、游戏：<a href="https://poki.com/zh/g/sky-mad">宝玩(poki)在线游戏集合—sky-mad</a></h3><p>这是一款飞行类游戏（网站内部多款游戏选择），玩法：按方向指引穿过标注框，键盘上下左右控制方向~~~<br><img src="/tomnyblog.github.io/images/games/gamePoki-skyMad.png" alt="宝玩(poki)—sky-mad images"> </p><h3 id="16、游戏：天宫看地球"><a href="#16、游戏：天宫看地球" class="headerlink" title="16、游戏：天宫看地球"></a>16、游戏：<a href="http://bigpixel.cn/city/menu/">天宫看地球</a></h3><p>这是一个使用天宫卫星查看城市的小游戏，目前仅支持查看20个城市，可使用鼠标放大与缩小主要的城市场景（注：点击中心旋转地球即可重新选择城市）~~~<br><img src="/tomnyblog.github.io/images/games/gameBigpixel.png" alt="天宫看地球 images"> </p><p><br><br><br><br><br>（待续…）<br><br><br></p><p>您有更多好玩的网页版在线游戏吗，评论区走一下~~</p><p><br><br></p><p style="font-size: 8px">    部分资源转载于：<br>    <a href="https://www.cnblogs.com/leesymbol/p/3270708.html" style="color: black;">www.cnblogs.com/leesymbol/</a><br>        <a href="https://onextrapixel.com/20-simple-html5-website-games-for-you-to-challenge-yourself/" style="color: black;">onextrapixel.com</a></p><p style="font-size: 10px">    本站商业转载需<a href="https://email.163.com/">联系博主:wyyx9082hgl@163.com</a>授权，非商业转载请注明出处。<br>    无法联系博主请在评论区注明，未经授权或无联系方式相关法律责任问题将追究。</p>]]></content>
    
    
    <categories>
      
      <category>webGames</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webGames</tag>
      
      <tag>小游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/tomnyblog.github.io/2024/04/24/hello-world/"/>
    <url>/tomnyblog.github.io/2024/04/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的Hexo博客。纪念博客的搭建到上线，第一篇博客为记录搭建到上线的过程，如有不足请指教~~~</p><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check #<a href="https://hexo.io/docs/">documentation</a> for more info.<br> If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><!-- ## Quick Start（注释方式与HTML一样） --><h4 id="以Windows系统搭建为例，前提条件：nodejs、git安装完成。可参考hexo官方文档"><a href="#以Windows系统搭建为例，前提条件：nodejs、git安装完成。可参考hexo官方文档" class="headerlink" title="以Windows系统搭建为例，前提条件：nodejs、git安装完成。可参考hexo官方文档"></a>以Windows系统搭建为例，前提条件：nodejs、git安装完成。可参考<a href="https://hexo.io/zh-cn/docs/">hexo</a>官方文档</h4><h3 id="1、Nodejs、Git本地部署已完成-可正常显示版本号"><a href="#1、Nodejs、Git本地部署已完成-可正常显示版本号" class="headerlink" title="1、Nodejs、Git本地部署已完成(可正常显示版本号)"></a>1、Nodejs、Git本地部署已完成(可正常显示版本号)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm -v    <span class="hljs-comment"># 命令生成对应版本号  </span><br><br>$ git -v    <span class="hljs-comment"># 命令生成对应版本号</span><br></code></pre></td></tr></table></figure><h3 id="2、本地下创建一个目录，目录下git-Bash打开初始化项目；"><a href="#2、本地下创建一个目录，目录下git-Bash打开初始化项目；" class="headerlink" title="2、本地下创建一个目录，目录下git Bash打开初始化项目；"></a>2、本地下创建一个目录，目录下git Bash打开初始化项目；</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init   <span class="hljs-comment"># 或 hexo init myblog 初始化到某文件夹，cd myblog 进入文件夹部署 </span><br></code></pre></td></tr></table></figure><h3 id="3、初始后输入命令打开本地服务地址，打开后为默认主题和hello-world页"><a href="#3、初始后输入命令打开本地服务地址，打开后为默认主题和hello-world页" class="headerlink" title="3、初始后输入命令打开本地服务地址，打开后为默认主题和hello world页"></a>3、初始后输入命令打开本地服务地址，打开后为默认主题和hello world页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server  <span class="hljs-comment"># 或简写 hexo s 生成本地服务地址，一般为 http://localhost:4000/</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="4、将项目部署到github，先将项目生成public静态资源文件夹，再上传到Github-Pages"><a href="#4、将项目部署到github，先将项目生成public静态资源文件夹，再上传到Github-Pages" class="headerlink" title="4、将项目部署到github，先将项目生成public静态资源文件夹，再上传到Github Pages"></a>4、将项目部署到github，先将项目生成public静态资源文件夹，再上传到Github Pages</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate  <span class="hljs-comment"># 或简写 hexo g 生成静态资源</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><!-- ### Deploy to remote sites --><h3 id="5、已注册并登陆github，创建新的仓库。注意点：-1-仓库名必须为your-name-github-io格式且设置为public公开。-2-点击仓库内的“Setting”-“Gages”，设置Branch的分支和目录-新手一般main和-root就行-并save保存。-3-需要使用ssh配置链接并上传的自行百度就可以，配置好config和密钥——需要使用ssh上传仓库时配置，否则可使用https连接：同-1-2-点击仓库内的“Setting”-“Gages”，设置“Build-and-deployment”的“source”为“Github-Actions”配置。同时需要在hexo项目根目录下的文件-config-yml内的deploy配置hexo上传的对应配置。"><a href="#5、已注册并登陆github，创建新的仓库。注意点：-1-仓库名必须为your-name-github-io格式且设置为public公开。-2-点击仓库内的“Setting”-“Gages”，设置Branch的分支和目录-新手一般main和-root就行-并save保存。-3-需要使用ssh配置链接并上传的自行百度就可以，配置好config和密钥——需要使用ssh上传仓库时配置，否则可使用https连接：同-1-2-点击仓库内的“Setting”-“Gages”，设置“Build-and-deployment”的“source”为“Github-Actions”配置。同时需要在hexo项目根目录下的文件-config-yml内的deploy配置hexo上传的对应配置。" class="headerlink" title="5、已注册并登陆github，创建新的仓库。注意点：(1)仓库名必须为your_name.github.io格式且设置为public公开。(2)点击仓库内的“Setting”-“Gages”，设置Branch的分支和目录(新手一般main和&#x2F;root就行)并save保存。(3)需要使用ssh配置链接并上传的自行百度就可以，配置好config和密钥——需要使用ssh上传仓库时配置，否则可使用https连接：同(1),(2)点击仓库内的“Setting”-“Gages”，设置“Build and deployment”的“source”为“Github Actions”配置。同时需要在hexo项目根目录下的文件_config.yml内的deploy配置hexo上传的对应配置。"></a>5、已注册并登陆github，创建新的仓库。注意点：(1)仓库名必须为your_name.github.io格式且设置为public公开。(2)点击仓库内的“Setting”-“Gages”，设置Branch的分支和目录(新手一般main和&#x2F;root就行)并save保存。(3)需要使用ssh配置链接并上传的自行百度就可以，配置好config和密钥——需要使用ssh上传仓库时配置，否则可使用https连接：同(1),(2)点击仓库内的“Setting”-“Gages”，设置“Build and deployment”的“source”为“Github Actions”配置。同时需要在hexo项目根目录下的文件_config.yml内的deploy配置hexo上传的对应配置。</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// _config.yml 配置</span><br><span class="hljs-symbol">url:</span> https:<span class="hljs-comment">//账号名.github.io/项目名.github.io/   # 配置博客地址</span><br><br>root： /    <span class="hljs-meta"># 一般默认，配置文件内不用配置和修改，主要对应github的分支路径</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@your_name:账号名/仓库名.github.io.git   <span class="hljs-meta"># 其中的your_name对于git的配置，一般为github.com</span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><h3 id="6、配置好github仓库和-config-yml内容后，在git-bash下载插件，再使用命令上传到github。-注意：如果出现多次端口上传失败，多上传几次。有错误查看对应信息修改相关配置-查看仓库上传成功后点击仓库内的“Setting”-“Gages”，“Visit-site”旁边的链接就是博客的地址。"><a href="#6、配置好github仓库和-config-yml内容后，在git-bash下载插件，再使用命令上传到github。-注意：如果出现多次端口上传失败，多上传几次。有错误查看对应信息修改相关配置-查看仓库上传成功后点击仓库内的“Setting”-“Gages”，“Visit-site”旁边的链接就是博客的地址。" class="headerlink" title="6、配置好github仓库和_config.yml内容后，在git bash下载插件，再使用命令上传到github。(注意：如果出现多次端口上传失败，多上传几次。有错误查看对应信息修改相关配置)查看仓库上传成功后点击仓库内的“Setting”-“Gages”，“Visit site”旁边的链接就是博客的地址。"></a>6、配置好github仓库和_config.yml内容后，在git bash下载插件，再使用命令上传到github。(注意：如果出现多次端口上传失败，多上传几次。有错误查看对应信息修改相关配置)查看仓库上传成功后点击仓库内的“Setting”-“Gages”，“Visit site”旁边的链接就是博客的地址。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm i hexo-deployer-git --save  <span class="hljs-comment"># 上传到仓库必须的插件</span><br><br>$ hexo deploy   <span class="hljs-comment"># 或简写hexo d 上传到github </span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><!-- ### Create a new post --><h3 id="7、博客上传成功后，修改博客内容再重新上传"><a href="#7、博客上传成功后，修改博客内容再重新上传" class="headerlink" title="7、博客上传成功后，修改博客内容再重新上传"></a>7、博客上传成功后，修改博客内容再重新上传</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;welcome&quot;</span>   <span class="hljs-comment"># 会在source的_posts文件夹下创建名为“welcome.md”页</span><br>$ hexo new page <span class="hljs-string">&quot;newwelcome&quot;</span>   <span class="hljs-comment"># 会在source的文件夹下创建名为“newwelcome”文件夹及资源</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="8、修改博客内容后，先使用hexo命令清理缓存或之前的静态资源，再输入命令在本地服务查看或上传github仓库"><a href="#8、修改博客内容后，先使用hexo命令清理缓存或之前的静态资源，再输入命令在本地服务查看或上传github仓库" class="headerlink" title="8、修改博客内容后，先使用hexo命令清理缓存或之前的静态资源，再输入命令在本地服务查看或上传github仓库"></a>8、修改博客内容后，先使用hexo命令清理缓存或之前的静态资源，再输入命令在本地服务查看或上传github仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean   <span class="hljs-comment"># 清除本地缓存或静态资源（会删除项目的public文件夹）</span><br>$ hexo g &amp;&amp; hexo s   <span class="hljs-comment"># 重新生成静态资源后并生成本地服务地址</span><br><br>$ hexo g &amp;&amp; hexo d   <span class="hljs-comment"># 重新生成静态资源后并上传到github仓库</span><br><br><span class="hljs-comment"># 可连接命令使用如：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></code></pre></td></tr></table></figure><h3 id="9、更换主题。可在hexo-theme官网选择多种免费主题，点击主题内有教程配置。"><a href="#9、更换主题。可在hexo-theme官网选择多种免费主题，点击主题内有教程配置。" class="headerlink" title="9、更换主题。可在hexo-theme官网选择多种免费主题，点击主题内有教程配置。"></a>9、更换主题。可在<a href="https://hexo.io/themes/">hexo-theme</a>官网选择多种免费主题，点击主题内有教程配置。</h3><h4 id="9-1-可使用git-clone或npm等多种方式下载主题包，这里使用npm下载fluid主题也是本站主题教程为例"><a href="#9-1-可使用git-clone或npm等多种方式下载主题包，这里使用npm下载fluid主题也是本站主题教程为例" class="headerlink" title="9.1 可使用git clone或npm等多种方式下载主题包，这里使用npm下载fluid主题也是本站主题教程为例"></a>9.1 可使用git clone或npm等多种方式下载主题包，这里使用npm下载fluid主题也是本站主题教程为例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm i --save hexo-theme-fluid   <span class="hljs-comment"># 下载主题包到本地项目</span><br></code></pre></td></tr></table></figure><h4 id="9-2-可按fluid主题配置教程配置，注意点："><a href="#9-2-可按fluid主题配置教程配置，注意点：" class="headerlink" title="9.2 可按fluid主题配置教程配置，注意点："></a>9.2 可按<a href="https://hexo.fluid-dev.com/docs/">fluid主题配置</a>教程配置，注意点：</h4><h5 id="1-主题包复制。本地使用npm下载包后，根目录themes文件夹内是没有包的-查看根目录文件package-json是否存在包-，需要在node-modules模块包管理内查找hexo-theme-fluid主题包并复制到根目录themes文件夹下。"><a href="#1-主题包复制。本地使用npm下载包后，根目录themes文件夹内是没有包的-查看根目录文件package-json是否存在包-，需要在node-modules模块包管理内查找hexo-theme-fluid主题包并复制到根目录themes文件夹下。" class="headerlink" title="(1).主题包复制。本地使用npm下载包后，根目录themes文件夹内是没有包的(查看根目录文件package.json是否存在包)，需要在node_modules模块包管理内查找hexo-theme-fluid主题包并复制到根目录themes文件夹下。"></a>(1).主题包复制。本地使用npm下载包后，根目录themes文件夹内是没有包的(查看根目录文件package.json是否存在包)，需要在node_modules模块包管理内查找hexo-theme-fluid主题包并复制到根目录themes文件夹下。</h5><h5 id="2-配置文件设置。将hexo-theme-fluid主题包内的配置文件-config-yml复制，在项目根目录下粘贴并修改为-config-fluid-yml文件名。"><a href="#2-配置文件设置。将hexo-theme-fluid主题包内的配置文件-config-yml复制，在项目根目录下粘贴并修改为-config-fluid-yml文件名。" class="headerlink" title="(2).配置文件设置。将hexo-theme-fluid主题包内的配置文件_config.yml复制，在项目根目录下粘贴并修改为_config.fluid.yml文件名。"></a>(2).配置文件设置。将hexo-theme-fluid主题包内的配置文件_config.yml复制，在项目根目录下粘贴并修改为_config.fluid.yml文件名。</h5><h5 id="3-在-config-yml文件修改为-theme：fluid-对应主题，后续博客内容修改配置一般在根目录-config-fluid-yml下。"><a href="#3-在-config-yml文件修改为-theme：fluid-对应主题，后续博客内容修改配置一般在根目录-config-fluid-yml下。" class="headerlink" title="(3).在_config.yml文件修改为 theme：fluid 对应主题，后续博客内容修改配置一般在根目录_config.fluid.yml下。"></a>(3).在_config.yml文件修改为 theme：fluid 对应主题，后续博客内容修改配置一般在根目录_config.fluid.yml下。</h5><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">修改主题配置后试运行和上传:<br>hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo s   # 本地服务查看主题配置后是否生效<br><br>hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d   # 本地确认主题生效上传到github<br></code></pre></td></tr></table></figure><h3 id="10、统计流量：本博客使用LeanCloud记录浏览量和访客数（也可以使用不蒜子或百度统计等方式进行网站统计管理）"><a href="#10、统计流量：本博客使用LeanCloud记录浏览量和访客数（也可以使用不蒜子或百度统计等方式进行网站统计管理）" class="headerlink" title="10、统计流量：本博客使用LeanCloud记录浏览量和访客数（也可以使用不蒜子或百度统计等方式进行网站统计管理）"></a>10、统计流量：本博客使用LeanCloud记录浏览量和访客数（也可以使用<a href="https://busuanzi.ibruce.info/">不蒜子</a>或<a href="https://tongji.baidu.com/web5/welcome/login">百度统计</a>等方式进行网站统计管理）</h3><h4 id="10-1-打开leancloud官网，点击‘免费使用’进入并注册登陆，登陆后个人实名认证和邮箱认证。认证完成后点击创建应用，选择‘开发版’即可，免费的"><a href="#10-1-打开leancloud官网，点击‘免费使用’进入并注册登陆，登陆后个人实名认证和邮箱认证。认证完成后点击创建应用，选择‘开发版’即可，免费的" class="headerlink" title="10.1 打开leancloud官网，点击‘免费使用’进入并注册登陆，登陆后个人实名认证和邮箱认证。认证完成后点击创建应用，选择‘开发版’即可，免费的"></a>10.1 打开<a href="https://www.leancloud.cn/">leancloud</a>官网，点击‘免费使用’进入并注册登陆，登陆后个人实名认证和邮箱认证。认证完成后点击创建应用，选择‘开发版’即可，免费的</h4><p><img src="/tomnyblog.github.io/images/lecOnePages/lecApp.png" alt="创建应用 images"> </p><p><span style="font-size:9px">markdown图片加载有<a href="https://hexo.io/zh-cn/docs/asset-folders.html">官方教程</a>。注意：括号内路径必须相对路径！(&#x2F;images&#x2F;your_name.png)</span></p><h4 id="10-2-进入应用，点击-设置-应用凭证，找到-AppID、AppKey和REST-API-服务器地址并记录，后面配置需要用"><a href="#10-2-进入应用，点击-设置-应用凭证，找到-AppID、AppKey和REST-API-服务器地址并记录，后面配置需要用" class="headerlink" title="10.2 进入应用，点击 设置-&gt;应用凭证，找到 AppID、AppKey和REST API 服务器地址并记录，后面配置需要用"></a>10.2 进入应用，点击 设置-&gt;应用凭证，找到 AppID、AppKey和REST API 服务器地址并记录，后面配置需要用</h4><p><img src="/tomnyblog.github.io/images/lecOnePages/lecAppkey.png" alt="生成应用凭证 images"> </p><h4 id="10-3-再打开项目根目录下-config-fluid-yml主题配置文件，文章和网页尾部流量统计的量和人数配置"><a href="#10-3-再打开项目根目录下-config-fluid-yml主题配置文件，文章和网页尾部流量统计的量和人数配置" class="headerlink" title="10.3 再打开项目根目录下_config.fluid.yml主题配置文件，文章和网页尾部流量统计的量和人数配置"></a>10.3 再打开项目根目录下_config.fluid.yml主题配置文件，文章和网页尾部流量统计的量和人数配置</h4><p><img src="/tomnyblog.github.io/images/lecOnePages/lecEnable.png" alt="配置流量统计开关 images"><br><img src="/tomnyblog.github.io/images/lecOnePages/lecIDkeyURL.png" alt="配置IDkeyUrl images"><br><img src="/tomnyblog.github.io/images/lecOnePages/lecHeadViews.png" alt="配置文章头部流量统计 images"><br><img src="/tomnyblog.github.io/images/lecOnePages/lecFooterPVUV.png" alt="配置文章网页尾部统计 images"> </p><h4 id="10-4-配置成功后，打开会显示文章头部和网页尾部统计样式"><a href="#10-4-配置成功后，打开会显示文章头部和网页尾部统计样式" class="headerlink" title="10.4 配置成功后，打开会显示文章头部和网页尾部统计样式"></a>10.4 配置成功后，打开会显示文章头部和网页尾部统计样式</h4><p><img src="/tomnyblog.github.io/images/lecOnePages/lecHeadImg.png" alt="文章头部统计样式 images"><br><img src="/tomnyblog.github.io/images/lecOnePages/lecFooterImg.png" alt="网页尾部统计样式 images"> </p><h3 id="11、评论：本博客使用LeanCloud的评论功能。也可以使用不蒜子或百度统计等方式"><a href="#11、评论：本博客使用LeanCloud的评论功能。也可以使用不蒜子或百度统计等方式" class="headerlink" title="11、评论：本博客使用LeanCloud的评论功能。也可以使用不蒜子或百度统计等方式"></a>11、评论：本博客使用LeanCloud的评论功能。也可以使用<a href="https://busuanzi.ibruce.info/">不蒜子</a>或<a href="https://tongji.baidu.com/web5/welcome/login">百度统计</a>等方式</h3><h4 id="11-1-在主题配置文件-config-fluid-yml-下找到comment-设置enable为true；type为valine"><a href="#11-1-在主题配置文件-config-fluid-yml-下找到comment-设置enable为true；type为valine" class="headerlink" title="11.1 在主题配置文件 _config.fluid.yml 下找到comment 设置enable为true；type为valine"></a>11.1 在主题配置文件 _config.fluid.yml 下找到comment 设置enable为true；type为valine</h4><p><br><img src="/tomnyblog.github.io/images/lecOnePages/lecComment.png" alt="配置评论功能开关 images"></p><h4 id="11-2-在主题配置文件-config-fluid-yml-下找到Valine-配置appID和appKey"><a href="#11-2-在主题配置文件-config-fluid-yml-下找到Valine-配置appID和appKey" class="headerlink" title="11.2 在主题配置文件 _config.fluid.yml 下找到Valine 配置appID和appKey"></a>11.2 在主题配置文件 _config.fluid.yml 下找到Valine 配置appID和appKey</h4><p><img src="/tomnyblog.github.io/images/lecOnePages/lecValine.png" alt="配置评论类型type的IDkey images"></p><h3 id="12、至此，基本配置完成！文章按官方文档配置和教程书写，也可按主题配置指南教程书写。"><a href="#12、至此，基本配置完成！文章按官方文档配置和教程书写，也可按主题配置指南教程书写。" class="headerlink" title="12、至此，基本配置完成！文章按官方文档配置和教程书写，也可按主题配置指南教程书写。"></a>12、至此，基本配置完成！文章按<a href="https://hexo.io/zh-cn/docs/writing">官方文档</a>配置和教程书写，也可按<a href="https://hexo.fluid-dev.com/docs/guide/#%E9%A6%96%E9%A1%B5">主题配置指南</a>教程书写。</h3><!-- <br><span style="font-size:8px">图片资源转载于[CSDN博主](https://blog.csdn.net/m0_61068009/article/details/138027129)</span> --><p><br><br><br></p><p style="font-size: 10px">    本站商业转载需<a href="https://email.163.com/">联系博主:wyyx9082hgl@163.com</a>授权，非商业转载请注明出处。<br>    无法联系博主请在评论区注明，未经授权或无联系方式相关法律责任问题将追究。</p>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>myHexoBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
